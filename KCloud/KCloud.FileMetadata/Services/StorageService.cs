using System.Text;using KCloud.FileMetadata.Interfaces;using KCloud.FileMetadata.Models.Entity;using Microsoft.Extensions.Localization;namespace KCloud.FileMetadata.Services;public class StorageService(IUnitOfWork unitOfWork, ILogger<StorageService> logger, IStringLocalizer localizer) : IStorageService{    public async Task<string> GenerateStoragePathAsync(        Guid userId,         string fileName,         Guid? folderId,         CancellationToken cancellationToken = default)    {        try        {            var pathBuilder = new StringBuilder();                        if (folderId.HasValue)            {                var folderPath = await BuildFolderPathAsync(folderId.Value, cancellationToken);                if (!string.IsNullOrEmpty(folderPath))                {                    pathBuilder.Append($"/{folderPath}");                }            }            var sanitizedFileName = SanitizeFileName(fileName);            pathBuilder.Append($"/{sanitizedFileName}");                        var generatedPath = pathBuilder.ToString();                        logger.LogDebug("Generated storage path: {Path} for user {UserId}", generatedPath, userId);                        return generatedPath;        }        catch (Exception ex)        {            logger.LogError(ex, "Error generating storage path for user {UserId}, file {FileName}", userId, fileName);                        // Fallback to simple path            var fallbackPrefix = Guid.NewGuid().ToString("N")[..8];            return $"users/{userId}/root/{fallbackPrefix}_{SanitizeFileName(fileName)}";        }    }    public string SanitizeFileName(string fileName)    {        if (string.IsNullOrWhiteSpace(fileName))        {            logger.LogWarning("Attempt to sanitize null or empty filename");            return "unnamed";        }                var invalidChars = Path.GetInvalidFileNameChars()            .Concat(new[] { '/', '\\', ':', '*', '?', '"', '<', '>', '|', ' ' })             .ToArray();                var sanitized = fileName;        foreach (var invalidChar in invalidChars)        {            sanitized = sanitized.Replace(invalidChar, '_');        }                // Remove leading/trailing dots and whitespace        sanitized = sanitized.Trim().Trim('.');                // Ensure we have something        if (string.IsNullOrEmpty(sanitized))        {            logger.LogWarning("Filename became empty after sanitization: {OriginalName}", fileName);            return localizer["UnnamedFile"].Value;         }                // Limit length        if (sanitized.Length > 200) // Leave room for prefix        {            sanitized = sanitized.Substring(0, 200);            logger.LogDebug("Truncated long filename from {Original} to {Sanitized}", fileName, sanitized);        }                return sanitized;    }    public bool IsValidFileName(string fileName)    {        if (string.IsNullOrWhiteSpace(fileName))         {            logger.LogDebug("Filename validation failed: null or whitespace");            return false;        }                if (fileName.Length > 255)         {            logger.LogDebug("Filename validation failed: too long ({Length} chars)", fileName.Length);            return false;        }                var invalidChars = Path.GetInvalidFileNameChars();        var hasInvalidChars = fileName.Any(c => invalidChars.Contains(c));                if (hasInvalidChars)        {            logger.LogDebug("Filename validation failed: contains invalid characters");            return false;        }                return true;    }    public async Task<string> BuildFolderPathAsync(Guid? folderId, CancellationToken cancellationToken)    {        if (!folderId.HasValue)            return localizer["Root"].Value;        var folderNames = new List<string>();        var currentFolderId = (Guid?)folderId;        var visitedFolders = new HashSet<Guid>();        var depth = 0;        const int maxDepth = 20;                 while (currentFolderId.HasValue && depth < maxDepth)        {            if (visitedFolders.Contains(currentFolderId.Value))            {                logger.LogWarning("Circular folder reference detected at folder {FolderId}", currentFolderId.Value);                break;            }                        visitedFolders.Add(currentFolderId.Value);                        var folder = await unitOfWork.Repository<Folder>().GetByIdAsync(currentFolderId.Value, cancellationToken);            if (folder == null)            {                logger.LogWarning("Folder {FolderId} not found while building path", currentFolderId.Value);                break;            }                        folderNames.Insert(0, folder.Name);            currentFolderId = folder.ParentFolderId;            depth++;        }                if (depth >= maxDepth)        {            logger.LogWarning("Maximum folder depth reached while building path for folder {FolderId}", folderId);        }                var path = string.Join("/", folderNames);        logger.LogDebug("Built folder path: {Path} for folder {FolderId}", path, folderId);                return path;    }}