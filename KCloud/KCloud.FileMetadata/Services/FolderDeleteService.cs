using KCloud.FileMetadata.Interfaces;using KCloud.FileMetadata.Models.Entity;using Microsoft.EntityFrameworkCore;namespace KCloud.FileMetadata.Services;public class FolderDeleteService(    IUnitOfWork unitOfWork,    IStorageService storageService,    ILogger<FolderDeleteService> logger) : IFolderDeleteService{   public async Task<List<Guid>> DeleteAllContentRecursivelyAsync(Folder folder, CancellationToken cancellationToken = default){    var deletedFileIds = new List<Guid>();        logger.LogDebug("Starting recursive deletion for folder {FolderId} with {FileCount} files and {SubFolderCount} subfolders",         folder.Id, folder.Files.Count, folder.SubFolders.Count);        // First: Soft delete all files in this folder and move them to root    foreach (var file in folder.Files)    {        file.IsDeleted = true;        file.DeletedAt = DateTime.UtcNow;        file.FolderId = null; // Move to root for easier cleanup                file.StoragePath = await storageService.GenerateStoragePathAsync(            file.UserId,            file.FileName,            null, // null = root            cancellationToken);                deletedFileIds.Add(file.Id);                logger.LogDebug("Soft deleted file {FileId} and moved storage to root: {StoragePath}",             file.Id, file.StoragePath);    }        // Second: Recursively process all subfolders BEFORE deleting them    foreach (var subFolder in folder.SubFolders)    {        // Load the full subfolder with all its children        var fullSubFolder = await unitOfWork.Repository<Folder>()            .Query()            .Include(f => f.Files.Where(file => !file.IsDeleted))            .Include(f => f.SubFolders.Where(sub => !sub.IsDeleted))            .FirstAsync(f => f.Id == subFolder.Id, cancellationToken);                // IMPORTANT: Recursively process the subfolder's content FIRST        var subFolderDeletedIds = await DeleteAllContentRecursivelyAsync(fullSubFolder, cancellationToken);        deletedFileIds.AddRange(subFolderDeletedIds);                logger.LogDebug("Processed subfolder {SubFolderId} content, found {DeletedFileCount} files",             subFolder.Id, subFolderDeletedIds.Count);    }        foreach (var subFolder in folder.SubFolders)    {        unitOfWork.Repository<Folder>().Delete(subFolder);        logger.LogDebug("Hard deleted now-empty subfolder {SubFolderId}", subFolder.Id);    }    logger.LogInformation("Completed recursive deletion for folder {FolderId}, total {DeletedFileCount} files soft deleted and moved to root",         folder.Id, deletedFileIds.Count);    return deletedFileIds;}    public async Task MoveContentToParentAsync(Folder folder, CancellationToken cancellationToken = default)    {        var targetFolderId = folder.ParentFolderId;        logger.LogInformation("Moving content from folder {FolderId} to parent folder {ParentFolderId}",            folder.Id, targetFolderId?.ToString() ?? "root");                        foreach (var subFolder in folder.SubFolders)        {            var oldParentId = subFolder.ParentFolderId;            subFolder.ParentFolderId = targetFolderId;            subFolder.LastAccessedAt = DateTime.UtcNow;            unitOfWork.Repository<Folder>().Update(subFolder);            logger.LogDebug("Moved subfolder {SubFolderId} from parent {OldParentId} to {NewParentId}",                subFolder.Id, oldParentId, targetFolderId?.ToString() ?? "root");        }        // Then move files        foreach (var file in folder.Files)        {            var oldFolderId = file.FolderId;            file.FolderId = targetFolderId;            file.LastAccessedAt = DateTime.UtcNow;            file.StoragePath = await storageService.GenerateStoragePathAsync(                file.UserId,                file.FileName,                targetFolderId,                cancellationToken);            unitOfWork.Repository<Models.Entity.FileMetadata>().Update(file);            logger.LogDebug(                "Moved file {FileId} from folder {OldFolderId} to {NewFolderId}, new storage path: {StoragePath}",                file.Id, oldFolderId, targetFolderId?.ToString() ?? "root", file.StoragePath);        }    }    public async Task MoveContentToRootAsync(Folder folder, CancellationToken cancellationToken = default)    {        logger.LogInformation("Moving content from folder {FolderId} to root", folder.Id);            // Move subfolders to root FIRST        foreach (var subFolder in folder.SubFolders)        {            var oldParentId = subFolder.ParentFolderId;            subFolder.ParentFolderId = null;            subFolder.LastAccessedAt = DateTime.UtcNow;                    unitOfWork.Repository<Folder>().Update(subFolder);                    logger.LogDebug("Moved subfolder {SubFolderId} from parent {OldParentId} to root",                 subFolder.Id, oldParentId);        }        // Then move files to root        foreach (var file in folder.Files)        {            var oldFolderId = file.FolderId;            file.FolderId = null;            file.LastAccessedAt = DateTime.UtcNow;                    file.StoragePath = await storageService.GenerateStoragePathAsync(                file.UserId,                file.FileName,                null, // null = root                cancellationToken);                    unitOfWork.Repository<Models.Entity.FileMetadata>().Update(file);                    logger.LogDebug("Moved file {FileId} from folder {OldFolderId} to root, new storage path: {StoragePath}",                 file.Id, oldFolderId, file.StoragePath);        }        // Save changes BEFORE deleting the folder        await unitOfWork.CommitAsync(cancellationToken);        logger.LogInformation("Completed moving {FileCount} files and {SubFolderCount} subfolders from folder {FolderId} to root",             folder.Files.Count, folder.SubFolders.Count, folder.Id);    }}