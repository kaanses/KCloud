// KCloud.Common/Helpers/StoragePathHelper.csusing System.Text;namespace KCloud.Common.Helpers;public static class StoragePathHelper{    public static async Task<string> GenerateStoragePathAsync<T>(        Guid userId,         string fileName,         Guid? folderId,         Func<Guid, Task<T>> getFolderById,        Func<T, Guid> getFolderId,        Func<T, string> getFolderName,        Func<T, Guid?> getParentFolderId)        where T : class    {        var pathBuilder = new StringBuilder();                // Start with user directory        pathBuilder.Append($"users/{userId}");                // Build folder hierarchy if folder is specified        if (folderId.HasValue)        {            var folderPath = await BuildFolderPathAsync(                folderId.Value,                 getFolderById,                 getFolderId,                 getFolderName,                 getParentFolderId);                        if (!string.IsNullOrEmpty(folderPath))            {                pathBuilder.Append($"/{folderPath}");            }        }        else        {            // Root folder            pathBuilder.Append("/root");        }                // Add filename with unique prefix to avoid conflicts        var uniquePrefix = Guid.NewGuid().ToString("N")[..8];        pathBuilder.Append($"/{uniquePrefix}_{SanitizeFileName(fileName)}");                return pathBuilder.ToString();    }        public static async Task<string> BuildFolderPathAsync<T>(        Guid folderId,        Func<Guid, Task<T>> getFolderById,        Func<T, Guid> getFolderId,        Func<T, string> getFolderName,        Func<T, Guid?> getParentFolderId)        where T : class    {        var folderNames = new List<string>();        var currentFolderId = (Guid?)folderId; // Start with the given folder ID        var visitedFolders = new HashSet<Guid>(); // Prevent infinite loops            // Traverse up the folder hierarchy        while (currentFolderId.HasValue)        {            // Prevent infinite loops            if (visitedFolders.Contains(currentFolderId.Value))            {                break;            }            visitedFolders.Add(currentFolderId.Value);                    var folder = await getFolderById(currentFolderId.Value);            if (folder == null)            {                break;            }                    // Add folder name to the beginning of the list (reverse order)            folderNames.Insert(0, SanitizeFileName(getFolderName(folder)));                    // Move to parent folder - THIS IS THE FIX            var parentId = getParentFolderId(folder);            if (!parentId.HasValue)            {                // This is a root folder, stop here                break;            }            currentFolderId = parentId.Value;        }            // Join folder names with forward slashes        return string.Join("/", folderNames);    }        private static string SanitizeFileName(string fileName)    {        if (string.IsNullOrEmpty(fileName))            return "unnamed";                // Remove or replace invalid characters for file paths        var invalidChars = Path.GetInvalidFileNameChars()            .Concat(new[] { '/', '\\', ':', '*', '?', '"', '<', '>', '|' })            .ToArray();                var sanitized = fileName;        foreach (var invalidChar in invalidChars)        {            sanitized = sanitized.Replace(invalidChar, '_');        }                // Trim whitespace and dots        sanitized = sanitized.Trim().Trim('.');                // Ensure it's not empty        return string.IsNullOrEmpty(sanitized) ? "unnamed" : sanitized;    }        public static string GetDirectoryPath(string fullStoragePath)    {        return Path.GetDirectoryName(fullStoragePath)?.Replace('\\', '/') ?? "";    }        public static string GetFileName(string fullStoragePath)    {        return Path.GetFileName(fullStoragePath) ?? "";    }}