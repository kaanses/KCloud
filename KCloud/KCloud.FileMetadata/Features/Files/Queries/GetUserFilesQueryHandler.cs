using Ardalis.Result;using AutoMapper;using KCloud.Common.Helpers;using KCloud.FileMetadata.Helpers;using KCloud.FileMetadata.Interfaces;using KCloud.FileMetadata.Models.DTO;using KCloud.FileMetadata.Models.Entity;using MediatR;using Microsoft.EntityFrameworkCore;using Microsoft.Extensions.Localization;namespace KCloud.FileMetadata.Features.Files.Queries;public class GetUserFilesQueryHandler(    IUnitOfWork unitOfWork,    IMapper mapper,    ILogger<GetUserFilesQueryHandler> logger,    IStringLocalizer localizer,    IHttpContextAccessor httpContextAccessor,    IStorageService storageService)    : IRequestHandler<GetUserFilesQuery, Result<UserFilesResponse>>{    public async Task<Result<UserFilesResponse>> Handle(GetUserFilesQuery request, CancellationToken cancellationToken)    {        try        {            var currentUserId = CurrentUserHelper.GetUserId(httpContextAccessor);            if (currentUserId == null)            {                return Result.Unauthorized(localizer["Unauthorized"]).Value;            }            logger.LogInformation(                "User: {UserId}, Folder: {FolderId}, SharedWithMe: {SharedWithMe}, IsTrash: {IsTrash}, SearchTerm: {SearchTerm}, OrderBy: {OrderBy}, Descending: {Descending}",                  currentUserId, request.FolderId, request.IsSharedWithMe, request.IsTrash, request.SearchTerm, request.OrderBy, request.Descending);            var allFilesQuery = unitOfWork.Repository<Models.Entity.FileMetadata>()                .Query()                .Include(f => f.Shares)                .Where(f => request.IsTrash ? f.IsDeleted : !f.IsDeleted);            List<Models.Entity.FileMetadata> files;            if (request.IsTrash)            {                files = await allFilesQuery                    .Where(f => f.UserId == currentUserId.Value)                    .ApplySearchFilter(request.SearchTerm)                    .ApplyOrdering(request.OrderBy, request.Descending)                    .ToListAsync(cancellationToken);                logger.LogInformation("Found {Count} deleted files in trash", files.Count);            }            else if (request.IsSharedWithMe)            {                files = await allFilesQuery                    .Where(f => f.Shares.Any(s =>                        s.SharedWithUserId == currentUserId.Value &&                        s.IsActive &&                        (s.ExpiresAt == null || s.ExpiresAt > DateTime.UtcNow)))                    .ApplySearchFilter(request.SearchTerm)                    .ApplyOrdering(request.OrderBy, request.Descending)                    .ToListAsync(cancellationToken);                logger.LogInformation("Found {Count} shared files", files.Count);            }            else if (request.FolderId == null || request.FolderId == Guid.Empty)            {                files = await allFilesQuery                    .Where(f => f.UserId == currentUserId.Value && f.FolderId == null)                    .ApplySearchFilter(request.SearchTerm)                    .ApplyOrdering(request.OrderBy, request.Descending)                    .ToListAsync(cancellationToken);                logger.LogInformation("Found {Count} owned files in ROOT folder", files.Count);            }            else            {                files = await allFilesQuery                    .Where(f => f.UserId == currentUserId.Value && f.FolderId == request.FolderId)                    .ApplySearchFilter(request.SearchTerm)                    .ApplyOrdering(request.OrderBy, request.Descending)                    .ToListAsync(cancellationToken);                logger.LogInformation("Found {Count} owned files in folder {FolderId}", files.Count, request.FolderId);            }            var folders = new List<Folder>();            if (!request.IsSharedWithMe && !request.IsTrash)            {                var targetParentFolderId = (request.FolderId == null || request.FolderId == Guid.Empty)                    ? null                    : request.FolderId;                folders = await unitOfWork.Repository<Folder>()                    .Query()                    .Where(f => f.ParentFolderId == targetParentFolderId &&                                f.UserId == currentUserId.Value &&                                !f.IsDeleted)                    .ApplyOrdering(request.OrderBy, request.Descending)                    .ToListAsync(cancellationToken);                logger.LogInformation("Found {Count} folders", folders.Count);            }            string currentFolderPath;            if (request.IsTrash)            {                currentFolderPath = "Trash";            }            else if (request.IsSharedWithMe)            {                currentFolderPath = "Shared with Me";            }            else if (request.FolderId == null || request.FolderId == Guid.Empty)            {                currentFolderPath = "Root";            }            else            {                currentFolderPath =                    await storageService.BuildFolderPathAsync(request.FolderId.Value, cancellationToken);            }            var response = new UserFilesResponse            {                Files = mapper.Map<List<FileMetadataDTO>>(files),                Folders = mapper.Map<List<FolderDTO>>(folders),                TotalFiles = files.Count,                TotalFolders = folders.Count,                CurrentFolderPath = currentFolderPath            };            logger.LogInformation("Final response - Files: {FileCount}, Folders: {FolderCount}",                response.Files.Count, response.Folders.Count);            return Result<UserFilesResponse>.Success(response);        }        catch (Exception ex)        {            logger.LogError(ex, "Error getting user files");            return Result<UserFilesResponse>.Error(localizer["FailedToRetrieveFiles"].Value);        }    }}