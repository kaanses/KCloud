using Ardalis.Result;using AutoMapper;using KCloud.Common.Helpers;using KCloud.FileMetadata.Helpers;using KCloud.FileMetadata.Interfaces;using KCloud.FileMetadata.Models.DTO;using KCloud.FileMetadata.Models.Entity;using MediatR;using Microsoft.EntityFrameworkCore;using Microsoft.Extensions.Localization;namespace KCloud.FileMetadata.Features.Files.Queries;public class GetUserFilesQueryHandler : IRequestHandler<GetUserFilesQuery, Result<UserFilesResponse>>{    private readonly IUnitOfWork _unitOfWork;    private readonly IMapper _mapper;    private readonly ILogger<GetUserFilesQueryHandler> _logger;    private readonly IStringLocalizer _localizer;    private readonly IHttpContextAccessor _httpContextAccessor;    public GetUserFilesQueryHandler(        IUnitOfWork unitOfWork,        IMapper mapper,        ILogger<GetUserFilesQueryHandler> logger,        IStringLocalizer localizer,        IHttpContextAccessor httpContextAccessor)    {        _unitOfWork = unitOfWork;        _mapper = mapper;        _logger = logger;        _localizer = localizer;        _httpContextAccessor = httpContextAccessor;    }    public async Task<Result<UserFilesResponse>> Handle(GetUserFilesQuery request, CancellationToken cancellationToken)    {        try        {            var currentUserId = CurrentUserHelper.GetUserId(_httpContextAccessor);            if (currentUserId == null)            {                return Result.Unauthorized(_localizer["Unauthorized"]).Value;            }            _logger.LogInformation("User: {UserId}, Folder: {FolderId}, SharedWithMe: {SharedWithMe}",                 currentUserId, request.FolderId, request.IsSharedWithMeFolder);            var allFilesQuery = _unitOfWork.Repository<Models.Entity.FileMetadata>()                .Query()                .Include(f => f.Shares)                .Where(f => !f.IsDeleted);            List<Models.Entity.FileMetadata> files;            if (request.IsSharedWithMeFolder)            {                files = await allFilesQuery                    .Where(f => f.Shares.Any(s =>                         s.SharedWithUserId == currentUserId.Value &&                        s.IsActive &&                        (s.ExpiresAt == null || s.ExpiresAt > DateTime.UtcNow)))                    .ToListAsync(cancellationToken);                                    _logger.LogInformation("Found {Count} shared files", files.Count);            }            else if (request.FolderId == null || request.FolderId == Guid.Empty)            {                files = await allFilesQuery                    .Where(f => f.UserId == currentUserId.Value && f.FolderId == null)                    .ToListAsync(cancellationToken);                                    _logger.LogInformation("Found {Count} owned files in ROOT folder", files.Count);            }            else            {                files = await allFilesQuery                    .Where(f => f.UserId == currentUserId.Value && f.FolderId == request.FolderId)                    .ToListAsync(cancellationToken);                                    _logger.LogInformation("Found {Count} owned files in folder {FolderId}", files.Count, request.FolderId);            }                        if (!string.IsNullOrWhiteSpace(request.SearchTerm))            {                var searchTerm = request.SearchTerm.ToLower();                files = files.Where(f =>                     f.FileName.ToLower().Contains(searchTerm) ||                    f.ContentType.ToLower().Contains(searchTerm)).ToList();                                    _logger.LogInformation("After search filter: {Count} files", files.Count);            }                        var folders = new List<Folder>();            if (!request.IsSharedWithMeFolder)            {                var targetParentFolderId = (request.FolderId == null || request.FolderId == Guid.Empty)                     ? null                     : request.FolderId;                folders = await _unitOfWork.Repository<Folder>()                    .Query()                    .Where(f => f.ParentFolderId == targetParentFolderId &&                                f.UserId == currentUserId.Value &&                                !f.IsDeleted)                    .ToListAsync(cancellationToken);                                    _logger.LogInformation("Found {Count} folders", folders.Count);            }                        var response = new UserFilesResponse            {                Files = _mapper.Map<List<FileMetadataDTO>>(files),                Folders = _mapper.Map<List<FolderDTO>>(folders),                TotalFiles = files.Count,                TotalFolders = folders.Count,                CurrentFolderPath = request.IsSharedWithMeFolder ? "Shared with Me" :                     (request.FolderId == null || request.FolderId == Guid.Empty) ? "Root" : "Folder"            };            _logger.LogInformation("Final response - Files: {FileCount}, Folders: {FolderCount}",                 response.Files.Count, response.Folders.Count);            return Result<UserFilesResponse>.Success(response);        }        catch (Exception ex)        {            _logger.LogError(ex, "Error getting user files");            return Result<UserFilesResponse>.Error(_localizer["FailedToRetrieveFiles"].Value);        }    }}