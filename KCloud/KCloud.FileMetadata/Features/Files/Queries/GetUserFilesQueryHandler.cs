using Ardalis.Result;using AutoMapper;using KCloud.Common.Helpers;using KCloud.FileMetadata.Helpers;using KCloud.FileMetadata.Interfaces;using KCloud.FileMetadata.Models.DTO;using KCloud.FileMetadata.Models.Entity;using KCloud.FileMetadata.Models.Enum;using MediatR;using Microsoft.EntityFrameworkCore;using Microsoft.Extensions.Localization;namespace KCloud.FileMetadata.Features.Files.Queries;public class GetUserFilesQueryHandler(    IUnitOfWork unitOfWork,    IMapper mapper,    ILogger<GetUserFilesQueryHandler> logger,    IStringLocalizer localizer,    IHttpContextAccessor httpContextAccessor,    IStorageService storageService)    : IRequestHandler<GetUserFilesQuery, Result<UserFilesResponse>>{    public async Task<Result<UserFilesResponse>> Handle(GetUserFilesQuery request, CancellationToken cancellationToken)    {        try        {            var currentUserId = CurrentUserHelper.GetUserId(httpContextAccessor);            if (currentUserId == null)            {                return Result.Unauthorized(localizer["Unauthorized"]).Value;            }            logger.LogInformation(                "User: {UserId}, Folder: {FolderId}, SharedWithMe: {SharedWithMe}, IsTrash: {IsTrash}, SearchTerm: {SearchTerm}, OrderBy: {OrderBy}, Descending: {Descending}",                  currentUserId, request.FolderId, request.IsSharedWithMe, request.IsTrash, request.SearchTerm, request.OrderBy, request.Descending);            List<FileMetadataDTO> fileDtos;            List<FolderDTO> folderDtos = new();            if (request.IsTrash)            {                // Trash files - use AutoMapper with owner permissions                var trashFiles = await unitOfWork.Repository<Models.Entity.FileMetadata>()                    .Query()                    .Where(f => f.IsDeleted && f.UserId == currentUserId.Value)                    .ApplySearchFilter(request.SearchTerm)                    .ApplyOrdering(request.OrderBy, request.Descending)                    .ToListAsync(cancellationToken);                fileDtos = mapper.Map<List<FileMetadataDTO>>(trashFiles);                // Set owner permissions for trash files                fileDtos.ForEach(dto => {                    dto.IsOwner = true;                    dto.UserPermission = FilePermission.FullAccess;                });                logger.LogInformation("Found {Count} deleted files in trash", fileDtos.Count);            }            else if (request.IsSharedWithMe)            {                // Shared files - use LINQ projection for permission calculation                fileDtos = await unitOfWork.Repository<Models.Entity.FileMetadata>()                    .Query()                    .Include(f => f.Shares)                    .Where(f => !f.IsDeleted && f.Shares.Any(s =>                        s.SharedWithUserId == currentUserId.Value &&                        s.IsActive &&                        (s.ExpiresAt == null || s.ExpiresAt > DateTime.UtcNow)))                    .ApplySearchFilter(request.SearchTerm)                    .ApplyOrdering(request.OrderBy, request.Descending)                    .Select(f => new FileMetadataDTO                    {                        Id = f.Id,                        FileName = f.FileName,                        ContentType = f.ContentType,                        FileSizeBytes = f.FileSizeBytes,                        UserId = f.UserId,                        FolderId = f.FolderId,                        UploadedAt = f.UploadedAt,                        LastAccessedAt = f.LastAccessedAt,                        IsShared = f.Shares.Any(s => s.IsActive && !s.IsPublic),                        HasPublicLink = f.Shares.Any(s => s.IsPublic && s.IsActive),                        // Custom permission logic                        IsOwner = f.UserId == currentUserId.Value,                        UserPermission = f.UserId == currentUserId.Value                             ? FilePermission.FullAccess                             : f.Shares                                .Where(s => s.SharedWithUserId == currentUserId.Value &&                                            s.IsActive &&                                            (s.ExpiresAt == null || s.ExpiresAt > DateTime.UtcNow))                                .OrderByDescending(s => s.SharedAt)                                .Select(s => s.Permission)                                .FirstOrDefault()                    })                    .ToListAsync(cancellationToken);                logger.LogInformation("Found {Count} shared files", fileDtos.Count);            }            else if (request.FolderId == null || request.FolderId == Guid.Empty)            {                // Root folder files - use AutoMapper with owner permissions                var rootFiles = await unitOfWork.Repository<Models.Entity.FileMetadata>()                    .Query()                    .Where(f => !f.IsDeleted && f.UserId == currentUserId.Value && f.FolderId == null)                    .ApplySearchFilter(request.SearchTerm)                    .ApplyOrdering(request.OrderBy, request.Descending)                    .ToListAsync(cancellationToken);                fileDtos = mapper.Map<List<FileMetadataDTO>>(rootFiles);                // Set owner permissions for owned files                fileDtos.ForEach(dto => {                    dto.IsOwner = true;                    dto.UserPermission = FilePermission.FullAccess;                });                logger.LogInformation("Found {Count} owned files in ROOT folder", fileDtos.Count);            }            else            {                // Specific folder files - use AutoMapper with owner permissions                var folderFiles = await unitOfWork.Repository<Models.Entity.FileMetadata>()                    .Query()                    .Where(f => !f.IsDeleted && f.UserId == currentUserId.Value && f.FolderId == request.FolderId)                    .ApplySearchFilter(request.SearchTerm)                    .ApplyOrdering(request.OrderBy, request.Descending)                    .ToListAsync(cancellationToken);                fileDtos = mapper.Map<List<FileMetadataDTO>>(folderFiles);                // Set owner permissions for owned files                fileDtos.ForEach(dto => {                    dto.IsOwner = true;                    dto.UserPermission = FilePermission.FullAccess;                });                logger.LogInformation("Found {Count} owned files in folder {FolderId}", fileDtos.Count, request.FolderId);            }            // Get folders (only for non-shared, non-trash views)            if (!request.IsSharedWithMe && !request.IsTrash)            {                var targetParentFolderId = (request.FolderId == null || request.FolderId == Guid.Empty)                    ? null                    : request.FolderId;                var folders = await unitOfWork.Repository<Folder>()                    .Query()                    .Where(f => f.ParentFolderId == targetParentFolderId &&                                f.UserId == currentUserId.Value &&                                !f.IsDeleted)                    .ApplyOrdering(request.OrderBy, request.Descending)                    .ToListAsync(cancellationToken);                folderDtos = mapper.Map<List<FolderDTO>>(folders);                logger.LogInformation("Found {Count} folders", folderDtos.Count);            }            // Build folder path            string currentFolderPath;            if (request.IsTrash)            {                currentFolderPath = "Trash";            }            else if (request.IsSharedWithMe)            {                currentFolderPath = "Shared with Me";            }            else if (request.FolderId == null || request.FolderId == Guid.Empty)            {                currentFolderPath = "Root";            }            else            {                currentFolderPath = await storageService.BuildFolderPathAsync(request.FolderId.Value, cancellationToken);            }            // Build response            var response = new UserFilesResponse            {                Files = fileDtos,                Folders = folderDtos,                TotalFiles = fileDtos.Count,                TotalFolders = folderDtos.Count,                CurrentFolderPath = currentFolderPath            };            logger.LogInformation("Final response - Files: {FileCount}, Folders: {FolderCount}",                response.Files.Count, response.Folders.Count);            return Result<UserFilesResponse>.Success(response);        }        catch (Exception ex)        {            logger.LogError(ex, "Error getting user files");            return Result<UserFilesResponse>.Error(localizer["FailedToRetrieveFiles"].Value);        }    }}