// KCloud.FileMetadata/Features/Files/Queries/GetUserFilesQueryHandler.csusing Ardalis.Result;using AutoMapper;using KCloud.Common.Helpers;using KCloud.FileMetadata.Helpers;using KCloud.FileMetadata.Interfaces;using KCloud.FileMetadata.Models.DTO;using KCloud.FileMetadata.Models.Entity;using MediatR;using Microsoft.EntityFrameworkCore;using Microsoft.Extensions.Localization;namespace KCloud.FileMetadata.Features.Files.Queries;public class GetUserFilesQueryHandler : IRequestHandler<GetUserFilesQuery, Result<UserFilesResponse>>{    private readonly IUnitOfWork _unitOfWork;    private readonly IMapper _mapper;    private readonly ILogger<GetUserFilesQueryHandler> _logger;    private readonly IStringLocalizer _localizer;    private readonly IHttpContextAccessor _httpContextAccessor;    public GetUserFilesQueryHandler(        IUnitOfWork unitOfWork,        IMapper mapper,        ILogger<GetUserFilesQueryHandler> logger,        IStringLocalizer localizer,        IHttpContextAccessor httpContextAccessor)    {        _unitOfWork = unitOfWork;        _mapper = mapper;        _logger = logger;        _localizer = localizer;        _httpContextAccessor = httpContextAccessor;    } public async Task<Result<UserFilesResponse>> Handle(GetUserFilesQuery request, CancellationToken cancellationToken)    {        try        {            var currentUserId = CurrentUserHelper.GetUserId(_httpContextAccessor);            if (currentUserId == null)            {                return Result.Unauthorized(_localizer["Unauthorized"]);            }            _logger.LogInformation("User: {UserId}, Folder: {FolderId}, SharedWithMe: {SharedWithMe}",                 currentUserId, request.FolderId, request.IsSharedWithMeFolder);            // Simple approach: Always get both owned and shared files, then filter            var allFilesQuery = _unitOfWork.Repository<Models.Entity.FileMetadata>()                .Query()                .Include(f => f.Shares)                .Where(f => !f.IsDeleted);            List<Models.Entity.FileMetadata> files;            if (request.IsSharedWithMeFolder || string.IsNullOrWhiteSpace(request.FolderId.ToString()))            {                // SHARED WITH ME: Only shared files                files = await allFilesQuery                    .Where(f => f.Shares.Any(s =>                         s.SharedWithUserId == currentUserId.Value &&                        s.IsActive &&                        (s.ExpiresAt == null || s.ExpiresAt > DateTime.UtcNow)))                    .ToListAsync(cancellationToken);                                    _logger.LogInformation("Found {Count} shared files", files.Count);            }            else            {                // REGULAR FOLDER: Only owned files in specific folder                files = await allFilesQuery                    .Where(f => f.UserId == currentUserId.Value && f.FolderId == request.FolderId)                    .ToListAsync(cancellationToken);                                    _logger.LogInformation("Found {Count} owned files in folder", files.Count);            }            // Apply search if needed            if (!string.IsNullOrWhiteSpace(request.SearchTerm))            {                var searchTerm = request.SearchTerm.ToLower();                files = files.Where(f =>                     f.FileName.ToLower().Contains(searchTerm) ||                    f.ContentType.ToLower().Contains(searchTerm)).ToList();            }            // Get folders (only for regular folders)            var folders = new List<Folder>();            if (!request.IsSharedWithMeFolder)            {                folders = await _unitOfWork.Repository<Folder>()                    .Query()                    .Where(f => f.ParentFolderId == request.FolderId &&                                f.UserId == currentUserId.Value &&                                !f.IsDeleted)                    .ToListAsync(cancellationToken);            }            // Build response            var response = new UserFilesResponse            {                Files = _mapper.Map<List<FileMetadataDTO>>(files),                Folders = _mapper.Map<List<FolderDTO>>(folders),                TotalFiles = files.Count,                TotalFolders = folders.Count,                CurrentFolderPath = request.IsSharedWithMeFolder ? "Shared with Me" : "Root"            };            return Result<UserFilesResponse>.Success(response);        }        catch (Exception ex)        {            _logger.LogError(ex, "Error getting user files");            return Result<UserFilesResponse>.Error(_localizer["FailedToRetrieveFiles"]);        }    }}