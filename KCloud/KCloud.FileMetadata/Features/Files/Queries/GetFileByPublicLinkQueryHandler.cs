using Ardalis.Result;using AutoMapper;using KCloud.FileMetadata.Interfaces;using KCloud.FileMetadata.Models.DTO;using MediatR;using Microsoft.EntityFrameworkCore;using Microsoft.Extensions.Localization;using FileShare = KCloud.FileMetadata.Models.Entity.FileShare;namespace KCloud.FileMetadata.Features.Files.Queries;public class GetFileByPublicLinkQueryHandler(    IUnitOfWork unitOfWork,    IMapper mapper,    ILogger<GetFileByPublicLinkQueryHandler> logger,    IStringLocalizer localizer)    : IRequestHandler<GetFileByPublicLinkQuery, Result<FileMetadataDTO>>{    public async Task<Result<FileMetadataDTO>> Handle(GetFileByPublicLinkQuery request, CancellationToken cancellationToken)    {        try        {            logger.LogInformation("Accessing file via public link: {PublicToken}", request.PublicToken);            // Find the public share by token            var publicShare = await unitOfWork.Repository<FileShare>()                .Query()                .Include(s => s.File)                .FirstOrDefaultAsync(s =>                     s.PublicLinkToken == request.PublicToken &&                    s.IsPublic &&                    s.IsActive,                    cancellationToken);            if (publicShare == null)            {                logger.LogWarning("Public link not found: {PublicToken}", request.PublicToken);                return Result<FileMetadataDTO>.Error(localizer["PublicLinkNotFound"]);            }            // Check if expired            if (publicShare.ExpiresAt.HasValue && publicShare.ExpiresAt.Value <= DateTime.UtcNow)            {                logger.LogWarning("Public link expired: {PublicToken}, expired at {ExpiresAt}",                     request.PublicToken, publicShare.ExpiresAt);                return Result<FileMetadataDTO>.Error(localizer["PublicLinkExpired"]);            }            // Check if the file still exists and is not deleted            if (publicShare.File == null || publicShare.File.IsDeleted)            {                logger.LogWarning("File not found or deleted for public link: {PublicToken}, FileId: {FileId}",                     request.PublicToken, publicShare.FileId);                return Result<FileMetadataDTO>.Error(localizer["FileNotFoundViaPublicLink"]);            }            // Map to DTO with public link context            var fileDto = mapper.Map<FileMetadataDTO>(publicShare.File);                        // Set permission context for public access            fileDto.IsOwner = false;            fileDto.UserPermission = publicShare.Permission;            // Update last accessed time            publicShare.File.LastAccessedAt = DateTime.UtcNow;            unitOfWork.Repository<Models.Entity.FileMetadata>().Update(publicShare.File);            await unitOfWork.CommitAsync(cancellationToken);            logger.LogInformation("Public file access granted for file {FileId} via token {PublicToken}",                 publicShare.FileId, request.PublicToken);            return Result<FileMetadataDTO>.Success(fileDto);        }        catch (Exception ex)        {            logger.LogError(ex, "Error accessing file via public link: {PublicToken}", request.PublicToken);            return Result<FileMetadataDTO>.Error(localizer["PublicLinkAccessFailed"]);        }    }}