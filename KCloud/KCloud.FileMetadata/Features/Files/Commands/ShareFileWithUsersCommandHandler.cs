using Ardalis.Result;using AutoMapper;using FluentValidation;using KCloud.Common.Helpers;using KCloud.FileMetadata.Helpers;using KCloud.FileMetadata.Interfaces;using KCloud.FileMetadata.Models.DTO;using MediatR;using Microsoft.EntityFrameworkCore;using Microsoft.Extensions.Localization;using FileShare = KCloud.FileMetadata.Models.Entity.FileShare;namespace KCloud.FileMetadata.Features.Files.Commands;public class ShareFileWithUsersCommandHandler(    IUnitOfWork unitOfWork,    IMapper mapper,    IValidator<ShareFileWithUsersCommand> validator,    ILogger<ShareFileWithUsersCommandHandler> logger,    IStringLocalizer localizer,    IHttpContextAccessor httpContextAccessor)    : IRequestHandler<ShareFileWithUsersCommand, Result<List<FileShareDTO>>>{    public async Task<Result<List<FileShareDTO>>> Handle(ShareFileWithUsersCommand request, CancellationToken cancellationToken)    {        try        {            var validationResult = await ValidationHelper.ValidateAsync(validator, request, logger);            if (!validationResult.IsSuccess)            {                return Result<List<FileShareDTO>>.Error(validationResult.Errors.FirstOrDefault());            }                        var currentUserId = CurrentUserHelper.GetUserId(httpContextAccessor);            if (currentUserId == null)            {                return Result.Unauthorized(localizer["Unauthorized"].Value);            }                        var file = await unitOfWork.Repository<Models.Entity.FileMetadata>()                .Query()                .Include(f => f.Shares)                .FirstOrDefaultAsync(f => f.Id == request.FileId && !f.IsDeleted, cancellationToken);            if (file == null)            {                return Result<List<FileShareDTO>>.Error(localizer["FileNotFound"].Value);            }                        var canShare = FilePermissionHelper.CanUserShareFile(file, currentUserId.Value);            if (!canShare)            {                return Result<List<FileShareDTO>>.Error(localizer["InsufficientPermissions"].Value);            }            var newShares = new List<FileShare>();            foreach (var userId in request.UserIds)            {                if (userId == currentUserId.Value)                    continue;                                var existingShare = file.Shares                    .FirstOrDefault(s => s.SharedWithUserId == userId && s.IsActive && !s.IsPublic);                if (existingShare != null)                {                    existingShare.Permission = request.Permission;                    existingShare.ExpiresAt = request.ExpiresAt;                    existingShare.SharedAt = DateTime.UtcNow;                    existingShare.SharedByUserId = currentUserId.Value;                    unitOfWork.Repository<FileShare>().Update(existingShare);                    newShares.Add(existingShare);                }                else                {                    var share = new FileShare                    {                        Id = Guid.NewGuid(),                        FileId = request.FileId,                        FileOwnerId = file.UserId,                        SharedByUserId = currentUserId.Value,                        SharedWithUserId = userId,                        Permission = request.Permission,                        SharedAt = DateTime.UtcNow,                        ExpiresAt = request.ExpiresAt,                        IsActive = true,                        IsPublic = false                    };                    await unitOfWork.Repository<FileShare>().AddAsync(share, cancellationToken);                    newShares.Add(share);                }            }            await unitOfWork.CommitAsync(cancellationToken);            var result = mapper.Map<List<FileShareDTO>>(newShares);            logger.LogInformation("File {FileId} shared with {UserCount} users by {SharedByUserId}",                request.FileId, request.UserIds.Count, currentUserId);            return Result<List<FileShareDTO>>.Success(result);        }        catch (Exception ex)        {            logger.LogError(ex, "Error sharing file {FileId}", request.FileId);            return Result<List<FileShareDTO>>.Error(localizer["FileSharingFailed"].Value);        }    }}