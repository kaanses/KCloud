using Ardalis.Result;using AutoMapper;using FluentValidation;using KCloud.Common.Helpers;using KCloud.FileMetadata.Helpers;using KCloud.FileMetadata.Interfaces;using KCloud.FileMetadata.Models.DTO;using MediatR;using Microsoft.EntityFrameworkCore;using Microsoft.Extensions.Localization;using FileShare = KCloud.FileMetadata.Models.Entity.FileShare;namespace KCloud.FileMetadata.Features.Files.Commands;public class ShareFileWithUsersCommandHandler(    IUnitOfWork unitOfWork,    IMapper mapper,    IValidator<ShareFileWithUsersCommand> validator,    ILogger<ShareFileWithUsersCommandHandler> logger,    IStringLocalizer localizer,    IHttpContextAccessor httpContextAccessor)    : IRequestHandler<ShareFileWithUsersCommand, Result<List<FileShareDTO>>>{    public async Task<Result<List<FileShareDTO>>> Handle(ShareFileWithUsersCommand request, CancellationToken cancellationToken)    {        var currentUserId = CurrentUserHelper.GetUserId(httpContextAccessor);                try        {            // Validate permission enum            var permission = FilePermissionHelper.GetFilePermission(request.Permission);            if (permission == null)            {                logger.LogWarning("Invalid permission {Permission} provided for file sharing", request.Permission);                return Result<List<FileShareDTO>>.Error(localizer["InvalidPermissionType"]);            }            // Validate command            var validationResult = await ValidationHelper.ValidateAsync(validator, request, logger);            if (!validationResult.IsSuccess)            {                return Result<List<FileShareDTO>>.Invalid(validationResult.ValidationErrors);            }                        if (currentUserId == null)            {                logger.LogWarning("Unauthenticated user attempted to share file {FileId}", request.FileId);                return Result<List<FileShareDTO>>.Unauthorized();            }                        // Get file with shares            var file = await unitOfWork.Repository<Models.Entity.FileMetadata>()                .Query()                .Include(f => f.Shares)                .FirstOrDefaultAsync(f => f.Id == request.FileId && !f.IsDeleted, cancellationToken);            if (file == null)            {                logger.LogWarning("File {FileId} not found for sharing by user {UserId}",                     request.FileId, currentUserId);                return Result<List<FileShareDTO>>.Error(localizer["FileNotFoundForSharing"]);            }                        // Check sharing permissions            var canShare = FilePermissionHelper.CanUserShareFile(file, currentUserId.Value);            if (!canShare)            {                logger.LogWarning("User {UserId} attempted to share file {FileId} without permission",                     currentUserId, request.FileId);                return Result<List<FileShareDTO>>.Error(localizer["InsufficientPermissionsShareFile"]);            }            var newShares = new List<FileShare>();            foreach (var userId in request.UserIds)            {                // Skip sharing with self                if (userId == currentUserId.Value)                {                    logger.LogDebug("Skipping self-share for user {UserId} on file {FileId}", userId, request.FileId);                    continue;                }                                // Check if share already exists                var existingShare = file.Shares                    .FirstOrDefault(s => s.SharedWithUserId == userId && s.IsActive && !s.IsPublic);                if (existingShare != null)                {                    // Update existing share                    existingShare.Permission = permission;                    existingShare.ExpiresAt = request.ExpiresAt;                    existingShare.SharedAt = DateTime.UtcNow;                    existingShare.SharedByUserId = currentUserId.Value;                    unitOfWork.Repository<FileShare>().Update(existingShare);                    newShares.Add(existingShare);                                        logger.LogInformation("Updated existing share for file {FileId} with user {SharedWithUserId}",                         request.FileId, userId);                }                else                {                    // Create new share                    var share = new FileShare                    {                        Id = Guid.NewGuid(),                        FileId = request.FileId,                        FileOwnerId = file.UserId,                        SharedByUserId = currentUserId.Value,                        SharedWithUserId = userId,                        Permission = permission,                        SharedAt = DateTime.UtcNow,                        ExpiresAt = request.ExpiresAt,                        IsActive = true,                        IsPublic = false                    };                    await unitOfWork.Repository<FileShare>().AddAsync(share, cancellationToken);                    newShares.Add(share);                                        logger.LogInformation("Created new share for file {FileId} with user {SharedWithUserId}",                         request.FileId, userId);                }            }            await unitOfWork.CommitAsync(cancellationToken);            var result = mapper.Map<List<FileShareDTO>>(newShares);            logger.LogInformation("File {FileId} shared with {UserCount} users by {SharedByUserId}",                request.FileId, request.UserIds.Count, currentUserId);            return Result<List<FileShareDTO>>.Success(result);        }        catch (Exception ex)        {            logger.LogError(ex, "Error sharing file {FileId} by user {UserId}",                 request.FileId, currentUserId?.ToString() ?? "Unknown");            return Result<List<FileShareDTO>>.Error(localizer["FileSharingFailed"]);        }    }}