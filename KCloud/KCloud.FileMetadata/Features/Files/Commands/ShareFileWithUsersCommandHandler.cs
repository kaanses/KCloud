// KCloud.FileMetadata/Features/Files/Commands/ShareFileWithUsersCommandHandler.csusing Ardalis.Result;using AutoMapper;using FluentValidation;using KCloud.Common.Helpers;using KCloud.FileMetadata.Helpers;using KCloud.FileMetadata.Interfaces;using KCloud.FileMetadata.Models.DTO;using KCloud.FileMetadata.Models.Entity;using MediatR;using Microsoft.EntityFrameworkCore;using Microsoft.Extensions.Localization;using FileShare = KCloud.FileMetadata.Models.Entity.FileShare;namespace KCloud.FileMetadata.Features.Files.Commands;public class ShareFileWithUsersCommandHandler : IRequestHandler<ShareFileWithUsersCommand, Result<List<FileShareDTO>>>{    private readonly IUnitOfWork _unitOfWork;    private readonly IMapper _mapper;    private readonly IValidator<ShareFileWithUsersCommand> _validator;    private readonly ILogger<ShareFileWithUsersCommandHandler> _logger;    private readonly IStringLocalizer _localizer;    private readonly IHttpContextAccessor _httpContextAccessor;    public ShareFileWithUsersCommandHandler(        IUnitOfWork unitOfWork,        IMapper mapper,        IValidator<ShareFileWithUsersCommand> validator,        ILogger<ShareFileWithUsersCommandHandler> logger,        IStringLocalizer localizer,        IHttpContextAccessor httpContextAccessor)    {        _unitOfWork = unitOfWork;        _mapper = mapper;        _validator = validator;        _logger = logger;        _localizer = localizer;        _httpContextAccessor = httpContextAccessor;    }    public async Task<Result<List<FileShareDTO>>> Handle(ShareFileWithUsersCommand request, CancellationToken cancellationToken)    {        try        {            // Validate the request            var validationResult = await ValidationHelper.ValidateAsync(_validator, request, _logger);            if (!validationResult.IsSuccess)            {                return Result<List<FileShareDTO>>.Error(validationResult.Errors.FirstOrDefault());            }            // Get current user            var currentUserId = CurrentUserHelper.GetUserId(_httpContextAccessor);            if (currentUserId == null)            {                return Result.Unauthorized(_localizer["Unauthorized"]);            }            // Get file with existing shares            var file = await _unitOfWork.Repository<Models.Entity.FileMetadata>()                .Query()                .Include(f => f.Shares)                .FirstOrDefaultAsync(f => f.Id == request.FileId && !f.IsDeleted, cancellationToken);            if (file == null)            {                return Result<List<FileShareDTO>>.Error(_localizer["FileNotFound"]);            }            // Check if user can share this file            var canShare = FilePermissionHelper.CanUserShareFile(file, currentUserId.Value);            if (!canShare)            {                return Result<List<FileShareDTO>>.Error(_localizer["InsufficientPermissions"]);            }            var newShares = new List<FileShare>();            foreach (var userId in request.UserIds)            {                // Don't share with yourself                if (userId == currentUserId.Value)                    continue;                // Check if already shared with this user                var existingShare = file.Shares                    .FirstOrDefault(s => s.SharedWithUserId == userId && s.IsActive && !s.IsPublic);                if (existingShare != null)                {                    // Update existing share                    existingShare.Permission = request.Permission;                    existingShare.ExpiresAt = request.ExpiresAt;                    existingShare.SharedAt = DateTime.UtcNow;                    existingShare.SharedByUserId = currentUserId.Value;                    _unitOfWork.Repository<FileShare>().Update(existingShare);                    newShares.Add(existingShare);                }                else                {                    // Create new share                    var share = new FileShare                    {                        Id = Guid.NewGuid(),                        FileId = request.FileId,                        FileOwnerId = file.UserId,                        SharedByUserId = currentUserId.Value,                        SharedWithUserId = userId,                        Permission = request.Permission,                        SharedAt = DateTime.UtcNow,                        ExpiresAt = request.ExpiresAt,                        IsActive = true,                        IsPublic = false                    };                    await _unitOfWork.Repository<FileShare>().AddAsync(share, cancellationToken);                    newShares.Add(share);                }            }            await _unitOfWork.CommitAsync(cancellationToken);            var result = _mapper.Map<List<FileShareDTO>>(newShares);            _logger.LogInformation("File {FileId} shared with {UserCount} users by {SharedByUserId}",                request.FileId, request.UserIds.Count, currentUserId);            return Result<List<FileShareDTO>>.Success(result);        }        catch (Exception ex)        {            _logger.LogError(ex, "Error sharing file {FileId}", request.FileId);            return Result<List<FileShareDTO>>.Error(_localizer["FileSharingFailed"]);        }    }}