using Ardalis.Result;using KCloud.Common.Helpers;using KCloud.FileMetadata.Interfaces;using MediatR;using Microsoft.EntityFrameworkCore;using Microsoft.Extensions.Localization;namespace KCloud.FileMetadata.Features.Files.Commands;public class RestoreFileCommandHandler(    IUnitOfWork unitOfWork,    ILogger<RestoreFileCommandHandler> logger,    IStringLocalizer localizer,    IHttpContextAccessor httpContextAccessor)    : IRequestHandler<RestoreFileCommand, Result>{    public async Task<Result> Handle(RestoreFileCommand request, CancellationToken cancellationToken)    {        var currentUserId = CurrentUserHelper.GetUserId(httpContextAccessor);                try        {            if (currentUserId == null)            {                logger.LogWarning("Unauthenticated user attempted to restore file(s)");                return Result.Unauthorized();            }            if (request.RestoreAll)            {                var deletedFiles = await unitOfWork.Repository<Models.Entity.FileMetadata>()                    .Query()                    .Where(f => f.IsDeleted && f.UserId == currentUserId.Value)                    .ToListAsync(cancellationToken);                if (!deletedFiles.Any())                {                    logger.LogInformation("No deleted files found for user {UserId}", currentUserId.Value);                    return Result.Success();                }                // Restore all files                foreach (var file in deletedFiles)                {                    file.IsDeleted = false;                    file.DeletedAt = null;                    unitOfWork.Repository<Models.Entity.FileMetadata>().Update(file);                }                await unitOfWork.CommitAsync(cancellationToken);                logger.LogInformation("Restored {Count} files for user {UserId}",                    deletedFiles.Count, currentUserId.Value);                return Result.Success();            }            else            {                if (request.Id == null)                {                    logger.LogWarning("File ID is required for single file restore by user {UserId}", currentUserId);                    return Result.Error(localizer["FileIdRequiredForRestore"]);                }                var file = await unitOfWork.Repository<Models.Entity.FileMetadata>()                    .Query()                    .FirstOrDefaultAsync(f => f.Id == request.Id && f.IsDeleted, cancellationToken);                if (file == null)                {                    logger.LogWarning("File {FileId} not found in trash for restore by user {UserId}",                         request.Id, currentUserId);                    return Result.Error(localizer["FileNotFoundInTrashForRestore"]);                }                if (file.UserId != currentUserId.Value)                {                    logger.LogWarning("User {UserId} attempted to restore file {FileId} without permission",                        currentUserId.Value, request.Id);                    return Result.Error(localizer["InsufficientPermissionsRestore"]);                }                file.IsDeleted = false;                file.DeletedAt = null;                unitOfWork.Repository<Models.Entity.FileMetadata>().Update(file);                await unitOfWork.CommitAsync(cancellationToken);                logger.LogInformation("File restored: {FileId} by user {UserId}", file.Id, currentUserId.Value);                return Result.Success();            }        }        catch (Exception ex)        {            logger.LogError(ex, "Error restoring file(s) - FileId: {FileId}, RestoreAll: {RestoreAll}, User: {UserId}",                request.Id, request.RestoreAll, currentUserId?.ToString() ?? "Unknown");            return Result.Error(localizer["FileRestoreFailed"]);        }    }}