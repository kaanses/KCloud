using Ardalis.Result;using KCloud.Common.Helpers;using KCloud.FileMetadata.Helpers;using KCloud.FileMetadata.Interfaces;using MediatR;using Microsoft.EntityFrameworkCore;using Microsoft.Extensions.Localization;namespace KCloud.FileMetadata.Features.Files.Commands;public class DeleteFileMetadataCommandHandler(    IUnitOfWork unitOfWork,    ILogger<DeleteFileMetadataCommandHandler> logger,    IStringLocalizer localizer,    IHttpContextAccessor httpContextAccessor)    : IRequestHandler<DeleteFileMetadataCommand, Result>{    public async Task<Result> Handle(DeleteFileMetadataCommand request, CancellationToken cancellationToken)    {        var currentUserId = CurrentUserHelper.GetUserId(httpContextAccessor);        if (currentUserId == null)        {            logger.LogWarning("Unauthenticated user attempted to delete file {FileId}", request.Id);            return Result.Unauthorized();        }        try        {            var file = await unitOfWork.Repository<Models.Entity.FileMetadata>()                .Query()                .Include(f => f.Shares)                .FirstOrDefaultAsync(f => f.Id == request.Id && !f.IsDeleted, cancellationToken);            if (file == null)            {                logger.LogWarning("File {FileId} not found for deletion by user {UserId}",                     request.Id, currentUserId);                return Result.Error(localizer["FileNotFoundForDeletion"]);            }                        var canDelete = FilePermissionHelper.CanUserDeleteFile(file, currentUserId.Value);            if (!canDelete)            {                logger.LogWarning("User {UserId} attempted to delete file {FileId} without permission",                     currentUserId, request.Id);                return Result.Error(localizer["InsufficientPermissionsDeleteFile"]);            }                        // Soft delete the file            file.IsDeleted = true;            file.DeletedAt = DateTime.UtcNow;            unitOfWork.Repository<Models.Entity.FileMetadata>().Update(file);            // Optionally deactivate all shares for the deleted file            if (file.Shares?.Any() == true)            {                foreach (var share in file.Shares.Where(s => s.IsActive))                {                    share.IsActive = false;                    unitOfWork.Repository<Models.Entity.FileShare>().Update(share);                }                logger.LogInformation("Deactivated {ShareCount} shares for deleted file {FileId}",                     file.Shares.Count(s => s.IsActive), file.Id);            }            await unitOfWork.CommitAsync(cancellationToken);            logger.LogInformation("File soft deleted: {FileId} by user {UserId}",                 file.Id, currentUserId);            return Result.Success();        }        catch (Exception ex)        {            logger.LogError(ex, "Error deleting file {FileId} by user {UserId}",                 request.Id, currentUserId);            return Result.Error(localizer["FileDeletionFailed"]);        }    }}