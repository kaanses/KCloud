using Ardalis.Result;using KCloud.Common.Helpers;using KCloud.FileMetadata.Interfaces;using KCloud.FileMetadata.Models.DTO;using MediatR;using Microsoft.EntityFrameworkCore;using Microsoft.Extensions.Localization;namespace KCloud.FileMetadata.Features.Files.Commands;public class HardDeleteFileCommandHandler(    IUnitOfWork unitOfWork,    ILogger<HardDeleteFileCommandHandler> logger,    IStringLocalizer localizer,    IHttpContextAccessor httpContextAccessor)    : IRequestHandler<HardDeleteFileCommand, Result<HardDeleteResultDTO>>{    public async Task<Result<HardDeleteResultDTO>> Handle(HardDeleteFileCommand request, CancellationToken cancellationToken)    {        var currentUserId = CurrentUserHelper.GetUserId(httpContextAccessor);                try        {            if (currentUserId == null)            {                logger.LogWarning("Unauthenticated user attempted to hard delete file {FileId}", request.FileId);                return Result<HardDeleteResultDTO>.Unauthorized();            }            var deletedFileIds = new List<Guid>();            if (request.EmptyTrash)            {                var deletedFiles = await unitOfWork.Repository<Models.Entity.FileMetadata>()                    .Query()                    .Where(f => f.UserId == currentUserId.Value && f.IsDeleted)                    .ToListAsync(cancellationToken);                if (!deletedFiles.Any())                {                    logger.LogInformation("No deleted files found to empty trash for user {UserId}", currentUserId);                    return Result<HardDeleteResultDTO>.Success(new HardDeleteResultDTO(deletedFileIds));                }                // Collect file IDs before deleting                deletedFileIds.AddRange(deletedFiles.Select(f => f.Id));                foreach (var item in deletedFiles)                {                    unitOfWork.Repository<Models.Entity.FileMetadata>().Delete(item);                }                await unitOfWork.CommitAsync(cancellationToken);                logger.LogInformation("Hard deleted {Count} files for user {UserId}", deletedFiles.Count, currentUserId);                                return Result<HardDeleteResultDTO>.Success(new HardDeleteResultDTO(deletedFileIds));            }                       var file = await unitOfWork.Repository<Models.Entity.FileMetadata>()                .Query()                .FirstOrDefaultAsync(f => f.Id == request.FileId && f.IsDeleted, cancellationToken);                        if (file == null)            {                logger.LogWarning("File {FileId} not found in trash for hard deletion by user {UserId}",                     request.FileId, currentUserId);                return Result<HardDeleteResultDTO>.Error(localizer["FileNotFoundInTrash"]);            }                         if (file.UserId != currentUserId.Value)            {                logger.LogWarning("User {UserId} attempted to hard delete file {FileId} without permission",                     currentUserId, request.FileId);                return Result<HardDeleteResultDTO>.Error(localizer["InsufficientPermissionsHardDelete"]);            }                        deletedFileIds.Add(file.Id);                        unitOfWork.Repository<Models.Entity.FileMetadata>().Delete(file);            await unitOfWork.CommitAsync(cancellationToken);            logger.LogInformation("Hard deleted file: {FileId} by user {UserId}", file.Id, currentUserId);                        return Result<HardDeleteResultDTO>.Success(new HardDeleteResultDTO(deletedFileIds));                    }        catch (Exception ex)        {            logger.LogError(ex, "Error hard deleting file {FileId} by user {UserId}",                 request.FileId, currentUserId?.ToString() ?? "Unknown");            return Result<HardDeleteResultDTO>.Error(localizer["FileHardDeleteFailed"]);        }    }}