using Ardalis.Result;using AutoMapper;using FluentValidation;using KCloud.Common.Helpers;using KCloud.FileMetadata.Helpers;using KCloud.FileMetadata.Interfaces;using KCloud.FileMetadata.Models.DTO;using MediatR;using Microsoft.EntityFrameworkCore;using Microsoft.Extensions.Localization;using FileShare = KCloud.FileMetadata.Models.Entity.FileShare;namespace KCloud.FileMetadata.Features.Files.Commands;public class CreatePublicLinkCommandHandler(    IUnitOfWork unitOfWork,    IMapper mapper,    IValidator<CreatePublicLinkCommand> validator,    ILogger<CreatePublicLinkCommandHandler> logger,    IStringLocalizer localizer,    IHttpContextAccessor httpContextAccessor)    : IRequestHandler<CreatePublicLinkCommand, Result<FileShareDTO>>{    public async Task<Result<FileShareDTO>> Handle(CreatePublicLinkCommand request, CancellationToken cancellationToken)    {        var currentUserId = CurrentUserHelper.GetUserId(httpContextAccessor);        if (currentUserId == null)        {            logger.LogWarning("Unauthenticated user attempted to create public link for file {FileId}", request.FileId);            return Result<FileShareDTO>.Unauthorized();        }        try        {            var validationResult = await ValidationHelper.ValidateAsync(validator, request, logger);            if (!validationResult.IsSuccess)            {                return Result<FileShareDTO>.Invalid(validationResult.ValidationErrors);            }                        var file = await unitOfWork.Repository<Models.Entity.FileMetadata>()                .Query()                .Include(f => f.Shares)                .FirstOrDefaultAsync(f => f.Id == request.FileId && !f.IsDeleted, cancellationToken);            if (file == null)            {                logger.LogWarning("File {FileId} not found for public link creation by user {UserId}",                     request.FileId, currentUserId);                return Result<FileShareDTO>.Error(localizer["FileNotFound"]);            }                        var canShare = FilePermissionHelper.CanUserShareFile(file, currentUserId.Value);            if (!canShare)            {                logger.LogWarning("User {UserId} attempted to create public link for file {FileId} without permission",                     currentUserId, request.FileId);                return Result<FileShareDTO>.Error(localizer["InsufficientPermissionsCreateLink"]);            }                        var existingPublicShare = file.Shares                .FirstOrDefault(s => s.IsPublic && s.IsActive);            if (existingPublicShare != null)            {                logger.LogInformation("Removing existing public link for file {FileId}", request.FileId);                unitOfWork.Repository<FileShare>().Delete(existingPublicShare);                await unitOfWork.CommitAsync(cancellationToken);            }                    var publicShare = new FileShare            {                Id = Guid.NewGuid(),                FileId = request.FileId,                FileOwnerId = file.UserId,                SharedByUserId = currentUserId.Value,                SharedWithUserId = null,                 Permission = request.Permission,                SharedAt = DateTime.UtcNow,                ExpiresAt = request.ExpiresAt,                IsActive = true,                IsPublic = true,                PublicLinkToken = FilePermissionHelper.GeneratePublicLinkToken()            };            await unitOfWork.Repository<FileShare>().AddAsync(publicShare, cancellationToken);            await unitOfWork.CommitAsync(cancellationToken);            var result = mapper.Map<FileShareDTO>(publicShare);            logger.LogInformation("Public link created for file {FileId} by user {UserId} with token {Token}",                request.FileId, currentUserId, publicShare.PublicLinkToken);            return Result<FileShareDTO>.Success(result);        }        catch (Exception ex)        {            logger.LogError(ex, "Error creating public link for file {FileId} by user {UserId}",                 request.FileId, currentUserId);            return Result<FileShareDTO>.Error(localizer["PublicLinkCreationFailed"]);        }    }}