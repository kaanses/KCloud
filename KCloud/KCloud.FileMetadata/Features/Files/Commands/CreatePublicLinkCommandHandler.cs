// KCloud.FileMetadata/Features/Files/Commands/CreatePublicLinkCommandHandler.csusing Ardalis.Result;using AutoMapper;using FluentValidation;using KCloud.Common.Helpers;using KCloud.FileMetadata.Helpers;using KCloud.FileMetadata.Interfaces;using KCloud.FileMetadata.Models.DTO;using KCloud.FileMetadata.Models.Entity;using MediatR;using Microsoft.EntityFrameworkCore;using Microsoft.Extensions.Localization;using FileShare = KCloud.FileMetadata.Models.Entity.FileShare;namespace KCloud.FileMetadata.Features.Files.Commands;public class CreatePublicLinkCommandHandler : IRequestHandler<CreatePublicLinkCommand, Result<FileShareDTO>>{    private readonly IUnitOfWork _unitOfWork;    private readonly IMapper _mapper;    private readonly IValidator<CreatePublicLinkCommand> _validator;    private readonly ILogger<CreatePublicLinkCommandHandler> _logger;    private readonly IStringLocalizer _localizer;    private readonly IHttpContextAccessor _httpContextAccessor;    public CreatePublicLinkCommandHandler(        IUnitOfWork unitOfWork,        IMapper mapper,        IValidator<CreatePublicLinkCommand> validator,        ILogger<CreatePublicLinkCommandHandler> logger,        IStringLocalizer localizer,        IHttpContextAccessor httpContextAccessor)    {        _unitOfWork = unitOfWork;        _mapper = mapper;        _validator = validator;        _logger = logger;        _localizer = localizer;        _httpContextAccessor = httpContextAccessor;    }    public async Task<Result<FileShareDTO>> Handle(CreatePublicLinkCommand request, CancellationToken cancellationToken)    {        try        {                        var currentUserId = CurrentUserHelper.GetUserId(_httpContextAccessor);            if (currentUserId == null)            {                return Result.Unauthorized(_localizer["Unauthorized"]);            }            // Get file            var file = await _unitOfWork.Repository<Models.Entity.FileMetadata>()                .Query()                .Include(f => f.Shares)                .FirstOrDefaultAsync(f => f.Id == request.FileId && !f.IsDeleted, cancellationToken);            if (file == null)            {                return Result<FileShareDTO>.Error(_localizer["FileNotFound"]);            }            // Check if user can share this file            var canShare = FilePermissionHelper.CanUserShareFile(file, currentUserId.Value);            if (!canShare)            {                return Result<FileShareDTO>.Error(_localizer["InsufficientPermissions"]);            }            // Check if public link already exists            var existingPublicShare = file.Shares                .FirstOrDefault(s => s.IsPublic && s.IsActive);            if (existingPublicShare != null)            {                // Update existing public link                existingPublicShare.Permission = request.Permission;                existingPublicShare.ExpiresAt = request.ExpiresAt;                existingPublicShare.SharedAt = DateTime.UtcNow;                existingPublicShare.SharedByUserId = currentUserId.Value;                _unitOfWork.Repository<FileShare>().Update(existingPublicShare);                await _unitOfWork.CommitAsync(cancellationToken);                var updatedResult = _mapper.Map<FileShareDTO>(existingPublicShare);                return Result<FileShareDTO>.Success(updatedResult);            }            // Create new public link            var publicShare = new FileShare            {                Id = Guid.NewGuid(),                FileId = request.FileId,                FileOwnerId = file.UserId,                SharedByUserId = currentUserId.Value,                SharedWithUserId = null, // Public link                Permission = request.Permission,                SharedAt = DateTime.UtcNow,                ExpiresAt = request.ExpiresAt,                IsActive = true,                IsPublic = true,                PublicLinkToken = GeneratePublicLinkToken()            };            await _unitOfWork.Repository<FileShare>().AddAsync(publicShare, cancellationToken);            await _unitOfWork.CommitAsync(cancellationToken);            var result = _mapper.Map<FileShareDTO>(publicShare);            _logger.LogInformation("Public link created for file {FileId} by user {UserId}",                request.FileId, currentUserId);            return Result<FileShareDTO>.Success(result);        }        catch (Exception ex)        {            _logger.LogError(ex, "Error creating public link for file {FileId}", request.FileId);            return Result<FileShareDTO>.Error(_localizer["PublicLinkCreationFailed"]);        }    }    private string GeneratePublicLinkToken()    {        return Guid.NewGuid().ToString("N")[..16]; // 16 character token    }}