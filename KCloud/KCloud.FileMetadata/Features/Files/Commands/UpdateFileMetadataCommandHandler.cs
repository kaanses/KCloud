// KCloud.FileMetadata/Features/Files/Commands/UpdateFileMetadataCommandHandler.csusing Ardalis.Result;using AutoMapper;using FluentValidation;using KCloud.Common.Helpers;using KCloud.FileMetadata.Helpers;using KCloud.FileMetadata.Interfaces;using KCloud.FileMetadata.Models.DTO;using KCloud.FileMetadata.Models.Entity;using MediatR;using Microsoft.EntityFrameworkCore;using Microsoft.Extensions.Localization;namespace KCloud.FileMetadata.Features.Files.Commands;public class UpdateFileMetadataCommandHandler : IRequestHandler<UpdateFileMetadataCommand, Result<FileMetadataDTO>>{    private readonly IUnitOfWork _unitOfWork;    private readonly IMapper _mapper;    private readonly IValidator<UpdateFileMetadataCommand> _validator;    private readonly ILogger<UpdateFileMetadataCommandHandler> _logger;    private readonly IStringLocalizer _localizer;    private readonly IHttpContextAccessor _httpContextAccessor;    public UpdateFileMetadataCommandHandler(        IUnitOfWork unitOfWork,        IMapper mapper,        IValidator<UpdateFileMetadataCommand> validator,        ILogger<UpdateFileMetadataCommandHandler> logger,        IStringLocalizer localizer,        IHttpContextAccessor httpContextAccessor)    {        _unitOfWork = unitOfWork;        _mapper = mapper;        _validator = validator;        _logger = logger;        _localizer = localizer;        _httpContextAccessor = httpContextAccessor;    }    public async Task<Result<FileMetadataDTO>> Handle(UpdateFileMetadataCommand request, CancellationToken cancellationToken)    {        try        {            // Validate the request            var validationResult = await ValidationHelper.ValidateAsync(_validator, request, _logger);            if (!validationResult.IsSuccess)            {                return Result<FileMetadataDTO>.Error(validationResult.Errors.FirstOrDefault());            }            // Get current user              var currentUserId = CurrentUserHelper.GetUserId(_httpContextAccessor);            if (currentUserId == null)            {                return Result.Unauthorized(_localizer["Unauthorized"]);            }            // Get file with shares to check permissions            var file = await _unitOfWork.Repository<Models.Entity.FileMetadata>()                .Query()                .Include(f => f.Shares)                .Include(f => f.Folder)                .FirstOrDefaultAsync(f => f.Id == request.Id && !f.IsDeleted, cancellationToken);            if (file == null)            {                return Result<FileMetadataDTO>.NotFound();            }            // âœ… Use permission helper            var canModify = FilePermissionHelper.CanUserModifyFile(file, currentUserId.Value);            if (!canModify)            {                return Result<FileMetadataDTO>.Forbidden();            }                        var originalFolderId = file.FolderId;            var originalFileName = file.FileName;            var needsStoragePathUpdate = false;                        if (request.FolderId != originalFolderId)            {                // Validate destination folder if moving                if (request.FolderId.HasValue)                {                    var folder = await _unitOfWork.Repository<Folder>().GetByIdAsync(request.FolderId.Value, cancellationToken);                    if (folder == null || folder.IsDeleted || folder.UserId != file.UserId)                    {                        return Result<FileMetadataDTO>.Error(_localizer["DestinationFolderNotFound"]);                    }                }                                file.FolderId = request.FolderId;                needsStoragePathUpdate = true;            }            // Check if filename is changing            if (!string.IsNullOrEmpty(request.FileName) && request.FileName != originalFileName)            {                file.FileName = request.FileName;                needsStoragePathUpdate = true;            }                        if (needsStoragePathUpdate)            {                file.StoragePath = await StoragePathHelper.GenerateStoragePathAsync(                    file.UserId,                    file.FileName,                    file.FolderId,                    // Delegate functions for folder operations                    async (id) => await _unitOfWork.Repository<Folder>().GetByIdAsync(id, cancellationToken),                    folder => folder.Id,                    folder => folder.Name,                    folder => folder.ParentFolderId                );            }            file.LastAccessedAt = DateTime.UtcNow;            _unitOfWork.Repository<Models.Entity.FileMetadata>().Update(file);            await _unitOfWork.CommitAsync(cancellationToken);            var result = _mapper.Map<FileMetadataDTO>(file);            _logger.LogInformation("File updated: {FileId} by user {UserId}", file.Id, currentUserId);            return Result<FileMetadataDTO>.Success(result);        }        catch (Exception ex)        {            _logger.LogError(ex, "Error updating file {FileId}", request.Id);            return Result<FileMetadataDTO>.Error(_localizer["FileUpdateFailed"]);        }    }}