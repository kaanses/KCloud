using Ardalis.Result;using AutoMapper;using FluentValidation;using KCloud.Common.Helpers;using KCloud.FileMetadata.Helpers;using KCloud.FileMetadata.Interfaces;using KCloud.FileMetadata.Models.DTO;using KCloud.FileMetadata.Models.Entity;using MediatR;using Microsoft.EntityFrameworkCore;using Microsoft.Extensions.Localization;namespace KCloud.FileMetadata.Features.Files.Commands;public class UpdateFileMetadataCommandHandler(    IUnitOfWork unitOfWork,    IMapper mapper,    IValidator<UpdateFileMetadataCommand> validator,    IStorageService storageService,    ILogger<UpdateFileMetadataCommandHandler> logger,    IStringLocalizer localizer,    IHttpContextAccessor httpContextAccessor)    : IRequestHandler<UpdateFileMetadataCommand, Result<FileMetadataDTO>>{    public async Task<Result<FileMetadataDTO>> Handle(UpdateFileMetadataCommand request,        CancellationToken cancellationToken)    {        var currentUserId = CurrentUserHelper.GetUserId(httpContextAccessor);                try        {            // Validation            var validationResult = await ValidationHelper.ValidateAsync(validator, request, logger);            if (!validationResult.IsSuccess)            {                return Result<FileMetadataDTO>.Invalid(validationResult.ValidationErrors);            }            if (currentUserId == null)            {                logger.LogWarning("Unauthenticated user attempted to update file {FileId}", request.Id);                return Result<FileMetadataDTO>.Unauthorized();            }                        // Get file with shares for permission checking            var file = await unitOfWork.Repository<Models.Entity.FileMetadata>()                .Query()                .Include(f => f.Shares)                .FirstOrDefaultAsync(f => f.Id == request.Id && !f.IsDeleted, cancellationToken);            if (file == null)            {                logger.LogWarning("File {FileId} not found for update by user {UserId}",                     request.Id, currentUserId);                return Result<FileMetadataDTO>.Error(localizer["FileNotFoundForUpdate"]);            }            // Check modification permissions            var canModify = FilePermissionHelper.CanUserModifyFile(file, currentUserId.Value);            if (!canModify)            {                logger.LogWarning("User {UserId} attempted to update file {FileId} without permission",                     currentUserId, request.Id);                return Result<FileMetadataDTO>.Error(localizer["InsufficientPermissionsUpdateFile"]);            }                        var changes = new List<string>();            var needsStoragePathUpdate = false;            // Handle filename update            if (!string.IsNullOrEmpty(request.FileName) && request.FileName != file.FileName)            {                var finalFileName = request.FileName;                                if (!storageService.IsValidFileName(request.FileName))                {                    finalFileName = storageService.SanitizeFileName(request.FileName);                    logger.LogInformation("Filename sanitized from '{Original}' to '{Sanitized}' for file {FileId}",                        request.FileName, finalFileName, file.Id);                }                                var originalExtension = ExtensionHelper.GetExtensionFromContentType(file.ContentType);                var newExtension = ExtensionHelper.GetExtensionFromFileName(finalFileName);                                if (string.IsNullOrEmpty(newExtension) || !newExtension.Equals(originalExtension, StringComparison.OrdinalIgnoreCase))                {                    var nameWithoutExtension = ExtensionHelper.RemoveExtensionFromFileName(finalFileName);                    finalFileName = nameWithoutExtension + originalExtension;                            logger.LogInformation("Extension preserved: added '{Extension}' based on content type '{ContentType}' for file {FileId}",                        originalExtension, file.ContentType, file.Id);                }                var oldFileName = file.FileName;                file.FileName = finalFileName;                needsStoragePathUpdate = true;                    if (finalFileName != request.FileName)                {                    changes.Add($"renamed from '{oldFileName}' to '{finalFileName}' (sanitized from '{request.FileName}')");                }                else                {                    changes.Add($"renamed from '{oldFileName}' to '{finalFileName}'");                }            }                        // Handle folder move            else if (request.FolderId != file.FolderId)            {                var oldFolderId = file.FolderId;                    if (request.FolderId.HasValue)                {                    var folder = await unitOfWork.Repository<Folder>()                        .GetByIdAsync(request.FolderId.Value, cancellationToken);                    if (folder == null || folder.IsDeleted)                    {                        return Result<FileMetadataDTO>.Error(localizer["DestinationFolderNotFound"]);                    }                                        if (folder.UserId != file.UserId)                    {                        return Result<FileMetadataDTO>.Error(localizer["DestinationFolderAccessDenied"]);                    }                }                file.FolderId = request.FolderId;                needsStoragePathUpdate = true;                var oldLocation = oldFolderId.HasValue ? $"folder {oldFolderId}" : "root";                var newLocation = request.FolderId.HasValue ? $"folder {request.FolderId}" : "root";                changes.Add($"moved from {oldLocation} to {newLocation}");            }                        // Update storage path if needed            if (needsStoragePathUpdate)            {                file.StoragePath = await storageService.GenerateStoragePathAsync(                    file.UserId,                    file.FileName,                    file.FolderId,                    cancellationToken);            }                        file.LastAccessedAt = DateTime.UtcNow;                        unitOfWork.Repository<Models.Entity.FileMetadata>().Update(file);            await unitOfWork.CommitAsync(cancellationToken);            var result = mapper.Map<FileMetadataDTO>(file);            if (changes.Any())            {                logger.LogInformation("File {FileId} updated by user {UserId}: {Changes}",                    file.Id, currentUserId, string.Join(", ", changes));            }            else            {                logger.LogDebug("No changes made to file {FileId} by user {UserId}", file.Id, currentUserId);            }            return Result<FileMetadataDTO>.Success(result);        }        catch (Exception ex)        {            logger.LogError(ex, "Error updating file {FileId} by user {UserId}",                 request.Id, currentUserId?.ToString() ?? "Unknown");            return Result<FileMetadataDTO>.Error(localizer["FileUpdateFailed"]);        }    }}