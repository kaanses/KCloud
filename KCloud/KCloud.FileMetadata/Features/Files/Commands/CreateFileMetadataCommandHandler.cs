// KCloud.FileMetadata/Features/Files/Commands/CreateFileMetadataCommandHandler.csusing Ardalis.Result;using AutoMapper;using FluentValidation;using KCloud.Common.Helpers;using KCloud.FileMetadata.Helpers;using KCloud.FileMetadata.Interfaces;using KCloud.FileMetadata.Models.DTO;using KCloud.FileMetadata.Models.Entity;using MediatR;using Microsoft.Extensions.Localization;namespace KCloud.FileMetadata.Features.Files.Commands;public class CreateFileMetadataCommandHandler : IRequestHandler<CreateFileMetadataCommand, Result<FileMetadataDTO>>{    private readonly IUnitOfWork _unitOfWork;    private readonly IMapper _mapper;    private readonly IValidator<CreateFileMetadataCommand> _validator;    private readonly ILogger<CreateFileMetadataCommandHandler> _logger;    private readonly IStringLocalizer _localizer;    private readonly IHttpContextAccessor _httpContextAccessor;    public CreateFileMetadataCommandHandler(        IUnitOfWork unitOfWork,        IMapper mapper,        IValidator<CreateFileMetadataCommand> validator,        ILogger<CreateFileMetadataCommandHandler> logger,        IStringLocalizer localizer,        IHttpContextAccessor httpContextAccessor)    {        _unitOfWork = unitOfWork;        _mapper = mapper;        _validator = validator;        _logger = logger;        _localizer = localizer;        _httpContextAccessor = httpContextAccessor;    }    public async Task<Result<FileMetadataDTO>> Handle(CreateFileMetadataCommand request, CancellationToken cancellationToken)    {        try        {            // ✅ Validate the request            var validationResult = await ValidationHelper.ValidateAsync(_validator, request, _logger);            if (!validationResult.IsSuccess)            {                return Result<FileMetadataDTO>.Error(validationResult.Errors.FirstOrDefault());            }            // ✅ Get current user            var currentUserId = CurrentUserHelper.GetUserId(_httpContextAccessor);            if (currentUserId == null)            {                return Result.Unauthorized(_localizer["Unauthorized"]);            }            // ✅ Validate folder if specified            if (request.FolderId.HasValue)            {                var folder = await _unitOfWork.Repository<Folder>().GetByIdAsync(request.FolderId.Value, cancellationToken);                if (folder == null || folder.IsDeleted || folder.UserId != currentUserId.Value)                {                    return Result<FileMetadataDTO>.Error(_localizer["FolderNotFoundOrAccessDenied"]);                }            }                        var storagePath = await StoragePathHelper.GenerateStoragePathAsync(                currentUserId.Value,                request.FileName,                request.FolderId,                // Delegate functions for folder operations                async (id) => await _unitOfWork.Repository<Folder>().GetByIdAsync(id, cancellationToken),                folder => folder.Id,                folder => folder.Name,                folder => folder.ParentFolderId            );            var fileMetadata = new Models.Entity.FileMetadata            {                Id = Guid.NewGuid(),                FileName = request.FileName,                ContentType = request.ContentType,                   FileSizeBytes = request.FileSizeBytes,                 UserId = currentUserId.Value,                FolderId = request.FolderId,                StoragePath = storagePath,                            UploadedAt = DateTime.UtcNow,                LastAccessedAt = DateTime.UtcNow,                IsDeleted = false            };            await _unitOfWork.Repository<Models.Entity.FileMetadata>().AddAsync(fileMetadata, cancellationToken);            await _unitOfWork.CommitAsync(cancellationToken);            var result = _mapper.Map<FileMetadataDTO>(fileMetadata);            _logger.LogInformation("File metadata created: {FileId} with path {StoragePath} by user {UserId}",                 fileMetadata.Id, storagePath, currentUserId);            return Result<FileMetadataDTO>.Success(result);        }        catch (Exception ex)        {            _logger.LogError(ex, "Error creating file metadata");            return Result<FileMetadataDTO>.Error(_localizer["FileCreationFailed"]);        }    }}