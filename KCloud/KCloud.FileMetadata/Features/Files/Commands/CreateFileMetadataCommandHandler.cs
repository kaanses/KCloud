using Ardalis.Result;using AutoMapper;using FluentValidation;using KCloud.Common.Helpers;using KCloud.FileMetadata.Helpers;using KCloud.FileMetadata.Interfaces;using KCloud.FileMetadata.Models.DTO;using KCloud.FileMetadata.Models.Entity;using MediatR;using Microsoft.Extensions.Localization;namespace KCloud.FileMetadata.Features.Files.Commands;public class CreateFileMetadataCommandHandler(    IUnitOfWork unitOfWork,    IMapper mapper,    IValidator<CreateFileMetadataCommand> validator,    IStorageService storageService,    ILogger<CreateFileMetadataCommandHandler> logger,    IStringLocalizer localizer,    IHttpContextAccessor httpContextAccessor)    : IRequestHandler<CreateFileMetadataCommand, Result<FileMetadataDTO>>{    public async Task<Result<FileMetadataDTO>> Handle(CreateFileMetadataCommand request, CancellationToken cancellationToken)    {        try        {            var currentUserId = CurrentUserHelper.GetUserId(httpContextAccessor);            if (currentUserId == null)            {                return Result<FileMetadataDTO>.Unauthorized();            }            // Validate folder if specified            if (request.FolderId.HasValue)            {                var folder = await unitOfWork.Repository<Folder>().GetByIdAsync(request.FolderId.Value, cancellationToken);                if (folder == null || folder.IsDeleted)                {                    return Result<FileMetadataDTO>.Error(localizer["FolderNotFound"]);                }                                if (folder.UserId != currentUserId.Value)                {                    return Result<FileMetadataDTO>.Error(localizer["FolderAccessDenied"]);                }            }                        // Sanitize filename if needed            var sanitizedFileName = request.FileName;            if (!storageService.IsValidFileName(request.FileName))            {                sanitizedFileName = storageService.SanitizeFileName(request.FileName);                logger.LogInformation("Filename sanitized from '{Original}' to '{Sanitized}' for new file",                     request.FileName, sanitizedFileName);            }                        // Generate storage path using service            var storagePath = await storageService.GenerateStoragePathAsync(                currentUserId.Value,                sanitizedFileName,                request.FolderId,                cancellationToken);            var fileMetadata = new Models.Entity.FileMetadata            {                Id = request.Id,                FileName = sanitizedFileName,                ContentType = request.ContentType,                FileSizeBytes = request.FileSizeBytes,                UserId = currentUserId.Value,                FolderId = request.FolderId,                StoragePath = storagePath,                UploadedAt = request.UploadedAt,                LastAccessedAt = DateTime.UtcNow,                IsDeleted = false            };            await unitOfWork.Repository<Models.Entity.FileMetadata>().AddAsync(fileMetadata, cancellationToken);            await unitOfWork.CommitAsync(cancellationToken);            var result = mapper.Map<FileMetadataDTO>(fileMetadata);            logger.LogInformation("File metadata created: {FileId} with path {StoragePath} by user {UserId}",                 fileMetadata.Id, storagePath, currentUserId);            return Result<FileMetadataDTO>.Success(result);        }        catch (Exception ex)        {            logger.LogError(ex, "Error creating file metadata for file {FileName}", request.FileName);            return Result<FileMetadataDTO>.Error(localizer["FileCreationFailed"]);        }    }}