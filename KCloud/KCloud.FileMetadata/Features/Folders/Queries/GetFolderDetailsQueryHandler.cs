// KCloud.FileMetadata/Features/Folders/Queries/GetFolderDetailsQueryHandler.csusing Ardalis.Result;using AutoMapper;using KCloud.Common.Helpers;using KCloud.FileMetadata.Helpers;using KCloud.FileMetadata.Interfaces;using KCloud.FileMetadata.Models.DTO;using KCloud.FileMetadata.Models.Entity;using MediatR;using Microsoft.EntityFrameworkCore;using Microsoft.Extensions.Localization;namespace KCloud.FileMetadata.Features.Folders.Queries;public class GetFolderDetailsQueryHandler : IRequestHandler<GetFolderDetailsQuery, Result<FolderDetailsDTO>>{    private readonly IUnitOfWork _unitOfWork;    private readonly IMapper _mapper;    private readonly ILogger<GetFolderDetailsQueryHandler> _logger;    private readonly IStringLocalizer _localizer;    private readonly IHttpContextAccessor _httpContextAccessor;    public GetFolderDetailsQueryHandler(        IUnitOfWork unitOfWork,        IMapper mapper,        ILogger<GetFolderDetailsQueryHandler> logger,        IStringLocalizer localizer,        IHttpContextAccessor httpContextAccessor)    {        _unitOfWork = unitOfWork;        _mapper = mapper;        _logger = logger;        _localizer = localizer;        _httpContextAccessor = httpContextAccessor;    }   public async Task<Result<FolderDetailsDTO>> Handle(GetFolderDetailsQuery request, CancellationToken cancellationToken)    {        try        {            var currentUserId = CurrentUserHelper.GetUserId(_httpContextAccessor);            if (currentUserId == null)            {                return Result.Unauthorized(_localizer["Unauthorized"]);            }            // Get folder without includes - simpler and faster            var folder = await _unitOfWork.Repository<Folder>()                .Query()                .FirstOrDefaultAsync(f => f.Id == request.Id && !f.IsDeleted, cancellationToken);            if (folder == null)            {                return Result<FolderDetailsDTO>.NotFound();            }            var canAccess = FilePermissionHelper.CanUserAccessFolder(folder, currentUserId.Value);            if (!canAccess)            {                return Result<FolderDetailsDTO>.Forbidden();            }            // Get counts with separate queries - much cleaner            var fileCount = await _unitOfWork.Repository<Models.Entity.FileMetadata>()                .Query()                .CountAsync(f => f.FolderId == folder.Id && !f.IsDeleted, cancellationToken);            var subFolderCount = await _unitOfWork.Repository<Folder>()                .Query()                .CountAsync(f => f.ParentFolderId == folder.Id && !f.IsDeleted, cancellationToken);            var totalSize = await _unitOfWork.Repository<Models.Entity.FileMetadata>()                .Query()                .Where(f => f.FolderId == folder.Id && !f.IsDeleted)                .SumAsync(f => (long?)f.FileSizeBytes, cancellationToken) ?? 0;            // Get breadcrumb path            var breadcrumbPath = await StoragePathHelper.BuildFolderPathAsync(                request.Id,                async (id) => await _unitOfWork.Repository<Folder>().GetByIdAsync(id, cancellationToken),                folder => folder.Id,                folder => folder.Name,                folder => folder.ParentFolderId            );            var result = new FolderDetailsDTO            {                Id = folder.Id,                Name = folder.Name,                UserId = folder.UserId,                ParentFolderId = folder.ParentFolderId,                CreatedAt = folder.CreatedAt,                LastAccessedAt = folder.LastAccessedAt,                BreadcrumbPath = string.IsNullOrEmpty(breadcrumbPath) ? folder.Name : $"Root > {breadcrumbPath.Replace("/", " > ")}",                FileCount = fileCount,                SubFolderCount = subFolderCount,                TotalSizeBytes = totalSize,            };            _logger.LogInformation("Retrieved folder details for {FolderId}: {FileCount} files, {FolderCount} subfolders",                 folder.Id, fileCount, subFolderCount);            return Result<FolderDetailsDTO>.Success(result);        }        catch (Exception ex)        {            _logger.LogError(ex, "Error getting folder details for {FolderId}", request.Id);            return Result<FolderDetailsDTO>.Error(_localizer["FailedToRetrieveFolderDetails"]);        }    }    private async Task<long> CalculateFolderSizeAsync(Guid folderId, CancellationToken cancellationToken)    {        // Get all files in this folder (recursively if needed)        var totalSize = await _unitOfWork.Repository<Models.Entity.FileMetadata>()            .Query()            .Where(f => f.FolderId == folderId && !f.IsDeleted)            .SumAsync(f => f.FileSizeBytes, cancellationToken);        // Get size of subfolders recursively        var subFolders = await _unitOfWork.Repository<Folder>()            .Query()            .Where(f => f.ParentFolderId == folderId && !f.IsDeleted)            .Select(f => f.Id)            .ToListAsync(cancellationToken);        foreach (var subFolderId in subFolders)        {            totalSize += await CalculateFolderSizeAsync(subFolderId, cancellationToken);        }        return totalSize;    }}