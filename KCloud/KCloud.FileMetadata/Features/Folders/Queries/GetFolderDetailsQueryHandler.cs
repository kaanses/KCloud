// KCloud.FileMetadata/Features/Folders/Queries/GetFolderDetailsQueryHandler.csusing Ardalis.Result;using AutoMapper;using KCloud.Common.Helpers;using KCloud.FileMetadata.Helpers;using KCloud.FileMetadata.Interfaces;using KCloud.FileMetadata.Models.DTO;using KCloud.FileMetadata.Models.Entity;using MediatR;using Microsoft.EntityFrameworkCore;using Microsoft.Extensions.Localization;namespace KCloud.FileMetadata.Features.Folders.Queries;public class GetFolderDetailsQueryHandler(    IUnitOfWork unitOfWork,    IMapper mapper,    ILogger<GetFolderDetailsQueryHandler> logger,    IStringLocalizer localizer,    IHttpContextAccessor httpContextAccessor)    : IRequestHandler<GetFolderDetailsQuery, Result<FolderDetailsDTO>>{    private readonly IMapper _mapper = mapper;    public async Task<Result<FolderDetailsDTO>> Handle(GetFolderDetailsQuery request, CancellationToken cancellationToken)    {        try        {            var currentUserId = CurrentUserHelper.GetUserId(httpContextAccessor);            if (currentUserId == null)            {                return Result.Unauthorized(localizer["Unauthorized"].Value);            }                        var folder = await unitOfWork.Repository<Folder>()                .Query()                .FirstOrDefaultAsync(f => f.Id == request.Id && !f.IsDeleted, cancellationToken);            if (folder == null)            {                return Result<FolderDetailsDTO>.NotFound();            }            var canAccess = FilePermissionHelper.CanUserAccessFolder(folder, currentUserId.Value);            if (!canAccess)            {                return Result<FolderDetailsDTO>.Forbidden();            }                        var fileCount = await unitOfWork.Repository<Models.Entity.FileMetadata>()                .Query()                .CountAsync(f => f.FolderId == folder.Id && !f.IsDeleted, cancellationToken);            var subFolderCount = await unitOfWork.Repository<Folder>()                .Query()                .CountAsync(f => f.ParentFolderId == folder.Id && !f.IsDeleted, cancellationToken);            var totalSize = await unitOfWork.Repository<Models.Entity.FileMetadata>()                .Query()                .Where(f => f.FolderId == folder.Id && !f.IsDeleted)                .SumAsync(f => (long?)f.FileSizeBytes, cancellationToken) ?? 0;                        var breadcrumbPath = await StoragePathHelper.BuildFolderPathAsync(                request.Id,                async (id) => await unitOfWork.Repository<Folder>().GetByIdAsync(id, cancellationToken),                folder => folder.Id,                folder => folder.Name,                folder => folder.ParentFolderId            );            var result = new FolderDetailsDTO            {                Id = folder.Id,                Name = folder.Name,                UserId = folder.UserId,                ParentFolderId = folder.ParentFolderId,                CreatedAt = folder.CreatedAt,                LastAccessedAt = folder.LastAccessedAt,                BreadcrumbPath = string.IsNullOrEmpty(breadcrumbPath) ? folder.Name : $"Root > {breadcrumbPath.Replace("/", " > ")}",                FileCount = fileCount,                SubFolderCount = subFolderCount,                TotalSizeBytes = totalSize,            };            logger.LogInformation("Retrieved folder details for {FolderId}: {FileCount} files, {FolderCount} subfolders",                 folder.Id, fileCount, subFolderCount);            return Result<FolderDetailsDTO>.Success(result);        }        catch (Exception ex)        {            logger.LogError(ex, "Error getting folder details for {FolderId}", request.Id);            return Result<FolderDetailsDTO>.Error(localizer["FailedToRetrieveFolderDetails"].Value);        }    }   }