using Ardalis.Result;using KCloud.Common.Helpers;using KCloud.FileMetadata.Helpers;using KCloud.FileMetadata.Interfaces;using KCloud.FileMetadata.Models.DTO;using KCloud.FileMetadata.Models.Entity;using MediatR;using Microsoft.EntityFrameworkCore;using Microsoft.Extensions.Localization;namespace KCloud.FileMetadata.Features.Folders.Queries;public class GetFolderDetailsQueryHandler(    IUnitOfWork unitOfWork,    IStorageService storageService,    ILogger<GetFolderDetailsQueryHandler> logger,    IStringLocalizer localizer,    IHttpContextAccessor httpContextAccessor)    : IRequestHandler<GetFolderDetailsQuery, Result<FolderDetailsDTO>>{    public async Task<Result<FolderDetailsDTO>> Handle(GetFolderDetailsQuery request, CancellationToken cancellationToken)    {        var currentUserId = CurrentUserHelper.GetUserId(httpContextAccessor);                try        {            if (currentUserId == null)            {                logger.LogWarning("Unauthenticated user attempted to access folder details {FolderId}", request.Id);                return Result<FolderDetailsDTO>.Unauthorized();            }                        var folder = await unitOfWork.Repository<Folder>()                .Query()                .FirstOrDefaultAsync(f => f.Id == request.Id && !f.IsDeleted, cancellationToken);            if (folder == null)            {                logger.LogWarning("User {UserId} attempted to access non-existent folder {FolderId}",                     currentUserId, request.Id);                return Result<FolderDetailsDTO>.Error(localizer["FolderNotFoundForDetails"]);            }                        var canAccess = FilePermissionHelper.CanUserAccessFolder(folder, currentUserId.Value);            if (!canAccess)            {                logger.LogWarning("User {UserId} attempted to access folder {FolderId} without permission",                     currentUserId, request.Id);                return Result<FolderDetailsDTO>.Error(localizer["InsufficientPermissionsAccessFolder"]);            }                        var fileCount = await unitOfWork.Repository<Models.Entity.FileMetadata>()                .Query()                .CountAsync(f => f.FolderId == folder.Id && !f.IsDeleted, cancellationToken);            var subFolderCount = await unitOfWork.Repository<Folder>()                .Query()                .CountAsync(f => f.ParentFolderId == folder.Id && !f.IsDeleted, cancellationToken);            var totalSize = await unitOfWork.Repository<Models.Entity.FileMetadata>()                .Query()                .Where(f => f.FolderId == folder.Id && !f.IsDeleted)                .SumAsync(f => (long?)f.FileSizeBytes, cancellationToken) ?? 0;                        string breadcrumbPath;            try            {                breadcrumbPath = await storageService.BuildFolderPathAsync(request.Id, cancellationToken);            }            catch (Exception pathEx)            {                logger.LogWarning(pathEx, "Failed to build breadcrumb path for folder {FolderId}, using fallback", request.Id);                breadcrumbPath = folder.Name;            }            var result = new FolderDetailsDTO            {                Id = folder.Id,                Name = folder.Name,                UserId = folder.UserId,                ParentFolderId = folder.ParentFolderId,                CreatedAt = folder.CreatedAt,                LastAccessedAt = folder.LastAccessedAt,                BreadcrumbPath = breadcrumbPath,                FileCount = fileCount,                SubFolderCount = subFolderCount,                TotalSizeBytes = totalSize,            };            logger.LogInformation("Retrieved folder details for {FolderId} by user {UserId}: {FileCount} files, {FolderCount} subfolders, {TotalSize} bytes",                 folder.Id, currentUserId, fileCount, subFolderCount, totalSize);            return Result<FolderDetailsDTO>.Success(result);        }        catch (Exception ex)        {            logger.LogError(ex, "Error getting folder details for {FolderId} by user {UserId}",                 request.Id, currentUserId?.ToString() ?? "Unknown");            return Result<FolderDetailsDTO>.Error(localizer["FailedToRetrieveFolderDetails"]);        }    }}