// KCloud.FileMetadata/Features/Folders/Commands/UpdateFolderCommandHandler.csusing Ardalis.Result;using AutoMapper;using FluentValidation;using KCloud.Common.Helpers;using KCloud.FileMetadata.Interfaces;using KCloud.FileMetadata.Models.DTO;using KCloud.FileMetadata.Models.Entity;using MediatR;using Microsoft.EntityFrameworkCore;using Microsoft.Extensions.Localization;namespace KCloud.FileMetadata.Features.Folders.Commands;public class UpdateFolderCommandHandler(    IUnitOfWork unitOfWork,    IMapper mapper,    IValidator<UpdateFolderCommand> validator,    ILogger<UpdateFolderCommandHandler> logger,    IStringLocalizer localizer,    IHttpContextAccessor httpContextAccessor)    : IRequestHandler<UpdateFolderCommand, Result<FolderDTO>>{    public async Task<Result<FolderDTO>> Handle(UpdateFolderCommand request, CancellationToken cancellationToken)    {        var currentUserId = CurrentUserHelper.GetUserId(httpContextAccessor);                try        {            // Validation            var validationResult = await ValidationHelper.ValidateAsync(validator, request, logger);            if (!validationResult.IsSuccess)            {                return Result<FolderDTO>.Invalid(validationResult.ValidationErrors);            }            if (currentUserId == null)            {                logger.LogWarning("Unauthenticated user attempted to update folder {FolderId}", request.Id);                return Result<FolderDTO>.Unauthorized();            }            // Get the folder to update            var folder = await unitOfWork.Repository<Folder>()                .Query()                .FirstOrDefaultAsync(f => f.Id == request.Id &&                                          f.UserId == currentUserId.Value &&                                          !f.IsDeleted, cancellationToken);            if (folder == null)            {                logger.LogWarning("User {UserId} attempted to update non-existent or unauthorized folder {FolderId}",                     currentUserId, request.Id);                return Result<FolderDTO>.Error(localizer["FolderNotFoundForUpdate"]);            }            var changes = new List<string>();                                    if (!string.IsNullOrWhiteSpace(request.Name) && request.Name != folder.Name)            {                var duplicateExists = await unitOfWork.Repository<Folder>()                    .Query()                    .AnyAsync(f => f.Name == request.Name &&                                   f.UserId == currentUserId.Value &&                                   f.ParentFolderId == folder.ParentFolderId &&                                  f.Id != request.Id &&                                  !f.IsDeleted, cancellationToken);                                if (duplicateExists)                {                    logger.LogWarning("User {UserId} attempted to rename folder {FolderId} to existing name '{Name}' in same location",                         currentUserId, request.Id, request.Name);                    return Result<FolderDTO>.Error(localizer["FolderNameAlreadyExistsInLocation"]);                }                var oldName = folder.Name;                folder.Name = request.Name;                changes.Add($"renamed from '{oldName}' to '{request.Name}'");            }                        if (request.ParentFolderId != folder.ParentFolderId)            {                if (request.ParentFolderId.HasValue)                {                    var parentFolder = await unitOfWork.Repository<Folder>()                        .Query()                        .FirstOrDefaultAsync(f => f.Id == request.ParentFolderId.Value &&                                                  f.UserId == currentUserId.Value &&                                                  !f.IsDeleted, cancellationToken);                                        if (parentFolder == null)                    {                        logger.LogWarning("User {UserId} attempted to move folder {FolderId} to non-existent parent {ParentId}",                             currentUserId, request.Id, request.ParentFolderId);                        return Result<FolderDTO>.Error(localizer["DestinationFolderNotFound"]);                    }                                        if (request.ParentFolderId.Value == folder.Id)                    {                        logger.LogWarning("User {UserId} attempted to move folder {FolderId} into itself",                             currentUserId, request.Id);                        return Result<FolderDTO>.Error(localizer["CannotMoveFolderIntoItself"]);                    }                                        var duplicateInDestination = await unitOfWork.Repository<Folder>()                        .Query()                        .AnyAsync(f => f.Name == folder.Name &&                                       f.UserId == currentUserId.Value &&                                       f.ParentFolderId == request.ParentFolderId &&                                      f.Id != request.Id &&                                      !f.IsDeleted, cancellationToken);                                        if (duplicateInDestination)                    {                        logger.LogWarning("User {UserId} attempted to move folder {FolderId} to location with duplicate name",                             currentUserId, request.Id);                        return Result<FolderDTO>.Error(localizer["FolderNameAlreadyExistsInDestination"]);                    }                }                var oldLocation = folder.ParentFolderId?.ToString() ?? "root";                var newLocation = request.ParentFolderId?.ToString() ?? "root";                folder.ParentFolderId = request.ParentFolderId;                changes.Add($"moved from {oldLocation} to {newLocation}");            }                        if (!changes.Any())            {                logger.LogDebug("No changes made to folder {FolderId} by user {UserId}", request.Id, currentUserId);                var existingResult = mapper.Map<FolderDTO>(folder);                return Result<FolderDTO>.Success(existingResult);            }            folder.LastAccessedAt = DateTime.UtcNow;            unitOfWork.Repository<Folder>().Update(folder);            await unitOfWork.CommitAsync(cancellationToken);            var result = mapper.Map<FolderDTO>(folder);            logger.LogInformation("Folder {FolderId} updated by user {UserId}: {Changes}",                 folder.Id, currentUserId, string.Join(", ", changes));                            return Result<FolderDTO>.Success(result);        }        catch (Exception ex)        {            logger.LogError(ex, "Error updating folder {FolderId} by user {UserId}",                 request.Id, currentUserId?.ToString() ?? "Unknown");            return Result<FolderDTO>.Error(localizer["FolderUpdateFailed"]);        }    }}