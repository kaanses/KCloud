// KCloud.FileMetadata/Features/Folders/Commands/UpdateFolderCommandHandler.csusing Ardalis.Result;using AutoMapper;using FluentValidation;using KCloud.Common.Helpers;using KCloud.FileMetadata.Helpers;using KCloud.FileMetadata.Interfaces;using KCloud.FileMetadata.Models.DTO;using KCloud.FileMetadata.Models.Entity;using MediatR;using Microsoft.EntityFrameworkCore;using Microsoft.Extensions.Localization;namespace KCloud.FileMetadata.Features.Folders.Commands;public class UpdateFolderCommandHandler : IRequestHandler<UpdateFolderCommand, Result<FolderDTO>>{    private readonly IUnitOfWork _unitOfWork;    private readonly IMapper _mapper;    private readonly IValidator<UpdateFolderCommand> _validator;    private readonly ILogger<UpdateFolderCommandHandler> _logger;    private readonly IStringLocalizer _localizer;    private readonly IHttpContextAccessor _httpContextAccessor;    public UpdateFolderCommandHandler(        IUnitOfWork unitOfWork,        IMapper mapper,        IValidator<UpdateFolderCommand> validator,        ILogger<UpdateFolderCommandHandler> logger,        IStringLocalizer localizer,        IHttpContextAccessor httpContextAccessor)    {        _unitOfWork = unitOfWork;        _mapper = mapper;        _validator = validator;        _logger = logger;        _localizer = localizer;        _httpContextAccessor = httpContextAccessor;    }        public async Task<Result<FolderDTO>> Handle(UpdateFolderCommand request, CancellationToken cancellationToken)    {        try        {            var validationResult = await ValidationHelper.ValidateAsync(_validator, request, _logger);            if (!validationResult.IsSuccess)            {                return Result<FolderDTO>.Error(validationResult.Errors.FirstOrDefault());            }            var currentUserId = CurrentUserHelper.GetUserId(_httpContextAccessor);            if (currentUserId == null)            {                return Result<FolderDTO>.Unauthorized();            }            var folder = await _unitOfWork.Repository<Folder>()                .Query()                .FirstOrDefaultAsync(f => f.Id == request.Id &&                                          f.UserId == currentUserId.Value &&                                          !f.IsDeleted, cancellationToken);            if (folder == null)            {                return Result<FolderDTO>.NotFound();            }            // Update name if provided            if (!string.IsNullOrWhiteSpace(request.Name))            {                folder.Name = request.Name;            }            // Update parent if it's different (including moving to root with null)            if (request.ParentFolderId != folder.ParentFolderId)            {                // Simple validation: just check if new parent exists and belongs to user                if (request.ParentFolderId.HasValue)                {                    var parentExists = await _unitOfWork.Repository<Folder>()                        .Query()                        .AnyAsync(f => f.Id == request.ParentFolderId.Value &&                                       f.UserId == currentUserId.Value &&                                       !f.IsDeleted, cancellationToken);                                        if (!parentExists)                    {                        return Result<FolderDTO>.Error(_localizer["ParentFolderNotFound"]);                    }                                        if (request.ParentFolderId.Value == folder.Id)                    {                        return Result<FolderDTO>.Error(_localizer["CannotMoveFolderIntoItself"]);                    }                }                folder.ParentFolderId = request.ParentFolderId;            }            folder.LastAccessedAt = DateTime.UtcNow;            _unitOfWork.Repository<Folder>().Update(folder);            await _unitOfWork.CommitAsync(cancellationToken);            var result = _mapper.Map<FolderDTO>(folder);            _logger.LogInformation("Folder updated: {FolderId} by user {UserId}", folder.Id, currentUserId);            return Result<FolderDTO>.Success(result);        }        catch (Exception ex)        {            _logger.LogError(ex, "Error updating folder {FolderId}", request.Id);            return Result<FolderDTO>.Error(_localizer["FolderUpdateFailed"]);        }    }}