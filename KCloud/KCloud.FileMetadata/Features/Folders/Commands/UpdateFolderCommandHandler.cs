// KCloud.FileMetadata/Features/Folders/Commands/UpdateFolderCommandHandler.csusing Ardalis.Result;using AutoMapper;using FluentValidation;using KCloud.Common.Helpers;using KCloud.FileMetadata.Interfaces;using KCloud.FileMetadata.Models.DTO;using KCloud.FileMetadata.Models.Entity;using MediatR;using Microsoft.EntityFrameworkCore;using Microsoft.Extensions.Localization;namespace KCloud.FileMetadata.Features.Folders.Commands;public class UpdateFolderCommandHandler(    IUnitOfWork unitOfWork,    IMapper mapper,    IValidator<UpdateFolderCommand> validator,    ILogger<UpdateFolderCommandHandler> logger,    IStringLocalizer localizer,    IHttpContextAccessor httpContextAccessor)    : IRequestHandler<UpdateFolderCommand, Result<FolderDTO>>{    public async Task<Result<FolderDTO>> Handle(UpdateFolderCommand request, CancellationToken cancellationToken)    {        try        {            var validationResult = await ValidationHelper.ValidateAsync(validator, request, logger);            if (!validationResult.IsSuccess)            {                return Result<FolderDTO>.Error(validationResult.Errors.FirstOrDefault());            }            var currentUserId = CurrentUserHelper.GetUserId(httpContextAccessor);            if (currentUserId == null)            {                return Result<FolderDTO>.Unauthorized(localizer["Unauthorized"].Value);            }            var folder = await unitOfWork.Repository<Folder>()                .Query()                .FirstOrDefaultAsync(f => f.Id == request.Id &&                                          f.UserId == currentUserId.Value &&                                          !f.IsDeleted, cancellationToken);            if (folder == null)            {                return Result<FolderDTO>.NotFound();            }                        if (!string.IsNullOrWhiteSpace(request.Name))            {                folder.Name = request.Name;            }                        if (request.ParentFolderId != folder.ParentFolderId)            {                if (request.ParentFolderId.HasValue)                {                    var parentExists = await unitOfWork.Repository<Folder>()                        .Query()                        .AnyAsync(f => f.Id == request.ParentFolderId.Value &&                                       f.UserId == currentUserId.Value &&                                       !f.IsDeleted, cancellationToken);                                        if (!parentExists)                    {                        return Result<FolderDTO>.Error(localizer["ParentFolderNotFound"].Value);                    }                                        if (request.ParentFolderId.Value == folder.Id)                    {                        return Result<FolderDTO>.Error(localizer["CannotMoveFolderIntoItself"].Value);                    }                }                folder.ParentFolderId = request.ParentFolderId;            }            folder.LastAccessedAt = DateTime.UtcNow;            unitOfWork.Repository<Folder>().Update(folder);            await unitOfWork.CommitAsync(cancellationToken);            var result = mapper.Map<FolderDTO>(folder);            logger.LogInformation("Folder updated: {FolderId} by user {UserId}", folder.Id, currentUserId);            return Result<FolderDTO>.Success(result);        }        catch (Exception ex)        {            logger.LogError(ex, "Error updating folder {FolderId}", request.Id);            return Result<FolderDTO>.Error(localizer["FolderUpdateFailed"].Value);        }    }}