// KCloud.FileMetadata/Features/Folders/Commands/DeleteFolderCommandHandler.csusing Ardalis.Result;using FluentValidation;using KCloud.Common.Helpers;using KCloud.FileMetadata.Helpers;using KCloud.FileMetadata.Interfaces;using KCloud.FileMetadata.Models.Entity;using MediatR;using Microsoft.EntityFrameworkCore;using Microsoft.Extensions.Localization;namespace KCloud.FileMetadata.Features.Folders.Commands;public class DeleteFolderCommandHandler : IRequestHandler<DeleteFolderCommand, Result>{    private readonly IUnitOfWork _unitOfWork;    private readonly ILogger<DeleteFolderCommandHandler> _logger;    private readonly IStringLocalizer _localizer;    private readonly IHttpContextAccessor _httpContextAccessor;    public DeleteFolderCommandHandler(        IUnitOfWork unitOfWork,        ILogger<DeleteFolderCommandHandler> logger,        IStringLocalizer localizer,        IHttpContextAccessor httpContextAccessor)    {        _unitOfWork = unitOfWork;        _logger = logger;        _localizer = localizer;        _httpContextAccessor = httpContextAccessor;    }    public async Task<Result> Handle(DeleteFolderCommand request, CancellationToken cancellationToken)    {        try        {                        var currentUserId = CurrentUserHelper.GetUserId(_httpContextAccessor);            if (currentUserId == null)            {                return Result.Unauthorized(_localizer["Unauthorized"]);            }            var folder = await _unitOfWork.Repository<Folder>()                .Query()                .Include(f => f.Files)                .Include(f => f.SubFolders)                .FirstOrDefaultAsync(f => f.Id == request.Id &&                                          f.UserId == currentUserId.Value &&                                          !f.IsDeleted, cancellationToken);            if (folder == null)            {                return Result.Error(_localizer["FolderNotFound"]);            }            // Check if folder has contents and deleteContents is false            if (!request.DeleteContents && (folder.Files.Any(f => !f.IsDeleted) || folder.SubFolders.Any(f => !f.IsDeleted)))            {                return Result.Error(_localizer["FolderNotEmpty"]);            }            // Soft delete folder            folder.IsDeleted = true;            folder.DeletedTime = DateTime.UtcNow;            // If deleteContents is true, also delete contents            if (request.DeleteContents)            {                foreach (var file in folder.Files.Where(f => !f.IsDeleted))                {                    file.IsDeleted = true;                    file.DeletedAt = DateTime.UtcNow;                }                foreach (var subFolder in folder.SubFolders.Where(f => !f.IsDeleted))                {                    subFolder.IsDeleted = true;                    subFolder.DeletedTime = DateTime.UtcNow;                }            }            _unitOfWork.Repository<Folder>().Update(folder);            await _unitOfWork.CommitAsync(cancellationToken);            _logger.LogInformation("Folder deleted: {FolderId} by user {UserId}", folder.Id, currentUserId);            return Result.Success();        }        catch (Exception ex)        {            _logger.LogError(ex, "Error deleting folder {FolderId}", request.Id);            return Result.Error(_localizer["FolderDeletionFailed"]);        }    }}