using Ardalis.Result;using KCloud.Common.Helpers;using KCloud.FileMetadata.Interfaces;using KCloud.FileMetadata.Models.DTO;using KCloud.FileMetadata.Models.Entity;using MediatR;using Microsoft.EntityFrameworkCore;using Microsoft.Extensions.Localization;namespace KCloud.FileMetadata.Features.Folders.Commands;public class DeleteFolderCommandHandler(    IUnitOfWork unitOfWork,    IFolderDeleteService folderDeleteService,    ILogger<DeleteFolderCommandHandler> logger,    IStringLocalizer localizer,    IHttpContextAccessor httpContextAccessor)    : IRequestHandler<DeleteFolderCommand, Result<DeleteFolderResponseDTO>>{    public async Task<Result<DeleteFolderResponseDTO>> Handle(DeleteFolderCommand request, CancellationToken cancellationToken)    {        try        {            var currentUserId = CurrentUserHelper.GetUserId(httpContextAccessor);            if (currentUserId == null)            {                return Result<DeleteFolderResponseDTO>.Unauthorized(localizer["Unauthorized"].Value);            }            var folder = await unitOfWork.Repository<Folder>()                .Query()                .Include(f => f.Files.Where(file => !file.IsDeleted))                .Include(f => f.SubFolders.Where(sub => !sub.IsDeleted))                .FirstOrDefaultAsync(f => f.Id == request.Id &&                                          f.UserId == currentUserId.Value &&                                          !f.IsDeleted, cancellationToken);            if (folder == null)            {                return Result<DeleteFolderResponseDTO>.Error(localizer["FolderNotFound"].Value);            }            var hasFiles = folder.Files.Any();            var hasSubFolders = folder.SubFolders.Any();            var hasContent = hasFiles || hasSubFolders;            if (hasContent && !request.DeleteContents && !request.MoveContentsToParent && !request.MoveContentsToRoot)            {                return Result<DeleteFolderResponseDTO>.Error(localizer["FolderNotEmpty"].Value);            }            var response = new DeleteFolderResponseDTO            {                Success = true,                Message = localizer["FolderDeletedSuccessfully"].Value            };            if (hasContent)            {                if (request.DeleteContents)                {                    logger.LogInformation("Deleting all content for folder {FolderId}", request.Id);                    var deletedFileIds = await folderDeleteService.DeleteAllContentRecursivelyAsync(folder, cancellationToken);                    response.DeletedFileIds = deletedFileIds;                    response.DeletedFileCount = deletedFileIds.Count;                }                else if (request.MoveContentsToParent)                {                    logger.LogInformation("Moving content to parent for folder {FolderId}", request.Id);                    await folderDeleteService.MoveContentToParentAsync(folder, cancellationToken);                }                else if (request.MoveContentsToRoot)                {                    logger.LogInformation("Moving content to root for folder {FolderId}", request.Id);                    await folderDeleteService.MoveContentToRootAsync(folder, cancellationToken);                }            }                     unitOfWork.Repository<Folder>().Delete(folder);            await unitOfWork.CommitAsync(cancellationToken);            logger.LogInformation("Successfully deleted folder {FolderId} by user {UserId} with action DeleteContents={DeleteContents}, MoveToParent={MoveToParent}, MoveToRoot={MoveToRoot}",                 folder.Id, currentUserId, request.DeleteContents, request.MoveContentsToParent, request.MoveContentsToRoot);            return Result<DeleteFolderResponseDTO>.Success(response);        }        catch (Exception ex)        {            logger.LogError(ex, "Error deleting folder {FolderId}", request.Id);            return Result<DeleteFolderResponseDTO>.Error(localizer["FolderDeletionFailed"].Value);        }    }}