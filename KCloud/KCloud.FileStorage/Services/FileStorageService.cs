using Ardalis.Result;using KCloud.FileStorage.Helpers;using KCloud.FileStorage.Interfaces;namespace KCloud.FileStorage.Services;public class FileStorageService : IFileStorageService{    private readonly ILogger<FileStorageService> _logger;    private readonly string _storageBasePath;    public FileStorageService(ILogger<FileStorageService> logger, IConfiguration configuration)    {        _logger = logger;        _storageBasePath = configuration["Storage:BasePath"] ??                           Path.Combine(Directory.GetCurrentDirectory(), "Storage");    }    public async Task<Result<string>> SaveFileAsync(IFormFile file, string storagePath,        CancellationToken cancellationToken = default)    {        try        {            var fullPath = Path.Combine(_storageBasePath, storagePath);            var directory = Path.GetDirectoryName(fullPath);            if (!string.IsNullOrEmpty(directory) && !Directory.Exists(directory))            {                Directory.CreateDirectory(directory);            }            using var stream = new FileStream(fullPath, FileMode.Create);            await file.CopyToAsync(stream, cancellationToken);            _logger.LogInformation("File saved successfully: {StoragePath}", storagePath);            return Result<string>.Success(fullPath);        }        catch (Exception ex)        {            _logger.LogError(ex, "Error saving file: {StoragePath}", storagePath);            return Result<string>.Error($"Failed to save file: {ex.Message}");        }    }    public Task<Result<Stream>> GetFileAsync(string storagePath, CancellationToken cancellationToken = default)    {        try        {            var fullPath = Path.Combine(_storageBasePath, storagePath);            if (!File.Exists(fullPath))            {                return Task.FromResult(Result<Stream>.NotFound("File not found"));            }            var stream = new FileStream(fullPath, FileMode.Open, FileAccess.Read);            return Task.FromResult(Result<Stream>.Success(stream));        }        catch (Exception ex)        {            _logger.LogError(ex, "Error retrieving file: {StoragePath}", storagePath);            return Task.FromResult(Result<Stream>.Error($"Failed to retrieve file: {ex.Message}"));        }    }    public Task<Result> DeleteFileAsync(string storagePath, CancellationToken cancellationToken = default)    {        try        {            var fullPath = Path.Combine(_storageBasePath, storagePath);            if (File.Exists(fullPath))            {                File.Delete(fullPath);                _logger.LogInformation("File deleted successfully: {StoragePath}", storagePath);            }            return Task.FromResult(Result.Success());        }        catch (Exception ex)        {            _logger.LogError(ex, "Error deleting file: {StoragePath}", storagePath);            return Task.FromResult(Result.Error($"Failed to delete file: {ex.Message}"));        }    }       public async Task<Result<string>> FindFileByIdAsync(Guid userId, Guid fileId, CancellationToken cancellationToken = default)    {        try        {            _logger.LogInformation("Searching for file - UserId: {UserId}, FileId: {FileId}", userId, fileId);                    var extensions = FileValidationHelper.GetSupportedExtensions();            foreach (var ext in extensions)            {                var potentialPath = $"users/{userId}/{fileId}{ext}";                var fullPath = Path.Combine(_storageBasePath, potentialPath);                            _logger.LogDebug("Checking path: {Path}", potentialPath);                            // Direct file check - no need for separate method                if (File.Exists(fullPath))                {                    _logger.LogInformation("Found file at: {Path}", potentialPath);                    return Result<string>.Success(potentialPath);                }            }            _logger.LogWarning("File not found - UserId: {UserId}, FileId: {FileId}", userId, fileId);            return Result<string>.NotFound("File not found");        }        catch (Exception ex)        {            _logger.LogError(ex, "Error searching for file: UserId: {UserId}, FileId: {FileId}", userId, fileId);            return Result<string>.Error($"Failed to search for file: {ex.Message}");        }    }}