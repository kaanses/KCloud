using FluentValidation;using KCloud.FileStorage.Features.Storage.Commands;using Microsoft.Extensions.Localization;using KCloud.Common.Resources;namespace KCloud.FileStorage.Validators;public class UploadFileCommandValidator : AbstractValidator<UploadFileCommand>{    private readonly IStringLocalizer _localizer;    private readonly IConfiguration _configuration;    // Default allowed types (can be overridden by configuration)    private static readonly string[] DefaultAllowedMimeTypes =    {        "image/jpeg", "image/png", "image/gif", "image/webp",        "application/pdf", "text/plain", "application/json",        "application/msword", "application/vnd.openxmlformats-officedocument.wordprocessingml.document",        "application/vnd.ms-excel", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"    };    private static readonly string[] DefaultAllowedExtensions =    {        ".pdf", ".jpg", ".jpeg", ".png", ".gif", ".webp", ".txt", ".json",        ".doc", ".docx", ".xls", ".xlsx"    };    public UploadFileCommandValidator(IStringLocalizer localizer, IConfiguration configuration)    {        _localizer = localizer;        _configuration = configuration;        // Get configuration values or use defaults        var maxFileSizeBytes = _configuration.GetValue<long>("FileUpload:MaxFileSizeBytes", 104_857_600); // Default 100MB                var allowedMimeTypes = _configuration.GetSection("FileUpload:AllowedMimeTypes").Get<string[]>()             ?? DefaultAllowedMimeTypes;                    var allowedExtensions = _configuration.GetSection("FileUpload:AllowedExtensions").Get<string[]>()             ?? DefaultAllowedExtensions;        // File validation rules        RuleFor(x => x.File)            .NotNull()            .WithMessage(_localizer["FileRequired"])                        .Must(file => file != null && file.Length > 0)            .WithMessage(_localizer["FileCannotBeEmpty"])                        .Must(file => file == null || file.Length <= maxFileSizeBytes)            .WithMessage(_localizer["FileSizeExceedsLimit", FormatFileSize(maxFileSizeBytes)])                        .Must(file => IsAllowedMimeType(file, allowedMimeTypes))            .WithMessage(_localizer["FileTypeNotAllowed"])                        .Must(file => IsAllowedExtension(file, allowedExtensions))            .WithMessage(_localizer["FileTypeNotAllowed"]);        // Folder validation rule        RuleFor(x => x.FolderId)            .Must(folderId => !folderId.HasValue || folderId.Value != Guid.Empty)            .WithMessage(_localizer["InvalidFolderId"])            .When(x => x.FolderId.HasValue);    }    private static bool IsAllowedMimeType(IFormFile? file, string[] allowedTypes)    {        if (file == null) return true; // Handled by NotNull rule        if (allowedTypes.Length == 0) return true; // Allow all if no restriction configured                return allowedTypes.Contains(file.ContentType?.ToLowerInvariant());    }    private static bool IsAllowedExtension(IFormFile? file, string[] allowedExtensions)    {        if (file == null) return true; // Handled by NotNull rule        if (allowedExtensions.Length == 0) return true; // Allow all if no restriction configured                var extension = Path.GetExtension(file.FileName)?.ToLowerInvariant();        return !string.IsNullOrEmpty(extension) && allowedExtensions.Contains(extension);    }    private static string FormatFileSize(long bytes)    {        string[] sizes = { "B", "KB", "MB", "GB" };        double len = bytes;        int order = 0;        while (len >= 1024 && order < sizes.Length - 1)        {            order++;            len = len / 1024;        }        return $"{len:0.##} {sizes[order]}";    }}