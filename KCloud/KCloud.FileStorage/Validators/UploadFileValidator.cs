using FluentValidation;using KCloud.FileStorage.Features.Storage.Commands;using Microsoft.Extensions.Localization;namespace KCloud.FileStorage.Validators;public class UploadFileCommandValidator : AbstractValidator<UploadFileCommand>{    private readonly IStringLocalizer _localizer;    private readonly IConfiguration _configuration;    public UploadFileCommandValidator(IStringLocalizer<UploadFileCommandValidator> localizer, IConfiguration configuration)    {        _localizer = localizer;        _configuration = configuration;        var maxFileSizeBytes = _configuration.GetValue<long>("FileUpload:MaxFileSizeBytes", 100_000_000); // Default 100MB        var allowedFileTypes = _configuration.GetSection("FileUpload:AllowedContentTypes").Get<string[]>()             ?? Array.Empty<string>();        RuleFor(x => x.File)            .NotNull().WithMessage(_localizer["FileRequired"])            .Must(file => file != null && file.Length > 0).WithMessage(_localizer["FileCannotBeEmpty"])            .Must(file => file == null || file.Length <= maxFileSizeBytes)                .WithMessage(_localizer["FileSizeExceedsLimit", FormatFileSize(maxFileSizeBytes)])            .Must(file => IsAllowedFileType(file, allowedFileTypes)).WithMessage(_localizer["FileTypeNotAllowed"])            .When(x => allowedFileTypes.Length > 0);         RuleFor(x => x.FolderId)            .Must(folderId => !folderId.HasValue || folderId.Value != Guid.Empty)            .WithMessage(_localizer["InvalidFolderId"])            .When(x => x.FolderId.HasValue);    }    private static bool IsAllowedFileType(IFormFile? file, string[] allowedTypes)    {        if (file == null || allowedTypes.Length == 0) return true; // Allow all if no restriction configured        return allowedTypes.Contains(file.ContentType?.ToLower());    }    private static string FormatFileSize(long bytes)    {        string[] sizes = { "B", "KB", "MB", "GB" };        double len = bytes;        int order = 0;        while (len >= 1024 && order < sizes.Length - 1)        {            order++;            len = len / 1024;        }        return $"{len:0.##} {sizes[order]}";    }}