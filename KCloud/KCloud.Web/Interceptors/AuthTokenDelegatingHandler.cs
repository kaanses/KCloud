using System.Net;using System.Net.Http.Headers;using System.Text;using System.Text.Json;using KCloud.Web.Interfaces;using KCloud.Web.Models.DTO;namespace KCloud.Web.Interceptors;public class AuthTokenDelegatingHandler : DelegatingHandler{    private readonly IAuthTokenService _tokenService;    private readonly IConfiguration _configuration;    private readonly ILogger<AuthTokenDelegatingHandler> _logger;    private static readonly object _refreshLock = new();    private static bool _isRefreshing = false;    public AuthTokenDelegatingHandler(        IAuthTokenService tokenService,        IConfiguration configuration,        ILogger<AuthTokenDelegatingHandler> logger)    {        _tokenService = tokenService;        _configuration = configuration;        _logger = logger;    }    protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)    {        var accessToken = _tokenService.GetAccessToken();                if (string.IsNullOrEmpty(accessToken))        {            _logger.LogInformation("No access token found, attempting refresh");                        var refreshSuccess = await TryRefreshToken(cancellationToken);            if (refreshSuccess)            {                accessToken = _tokenService.GetAccessToken();                _logger.LogInformation("Token refreshed successfully");            }            else            {                _logger.LogWarning("No access token and refresh failed");                return new HttpResponseMessage(HttpStatusCode.Unauthorized)                {                    Content = new StringContent("Authentication required")                };            }        }        if (!string.IsNullOrEmpty(accessToken))        {            request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", accessToken);        }                var response = await base.SendAsync(request, cancellationToken);                if (response.StatusCode == HttpStatusCode.Unauthorized && !_isRefreshing)        {            _logger.LogInformation("Received 401, attempting token refresh");            var refreshSuccess = await TryRefreshToken(cancellationToken);            if (refreshSuccess)            {                _logger.LogInformation("Token refreshed, retrying request");                // Update the request with new token                var newAccessToken = _tokenService.GetAccessToken();                if (!string.IsNullOrEmpty(newAccessToken))                {                    request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", newAccessToken);                    response = await base.SendAsync(request, cancellationToken);                }            }            else            {                _logger.LogWarning("Token refresh failed, clearing tokens");                _tokenService.ClearTokens();            }        }        return response;    }    private async Task<bool> TryRefreshToken(CancellationToken cancellationToken)    {        lock (_refreshLock)        {            if (_isRefreshing) return false;            _isRefreshing = true;        }        try        {            var refreshToken = _tokenService.GetRefreshToken();            if (string.IsNullOrEmpty(refreshToken))            {                _logger.LogWarning("No refresh token available");                return false;            }            // Get gateway URL from configuration            var gatewayUrl = _configuration["Gateway:BaseUrl"] ?? "http://localhost:5178/";                        using var httpClient = new HttpClient();            httpClient.BaseAddress = new Uri(gatewayUrl);            var refreshData = new { RefreshToken = refreshToken };            var json = JsonSerializer.Serialize(refreshData);            var content = new StringContent(json, Encoding.UTF8, "application/json");            var response = await httpClient.PostAsync("/auth/refresh", content, cancellationToken);            if (response.IsSuccessStatusCode)            {                var responseContent = await response.Content.ReadAsStringAsync(cancellationToken);                                var result = JsonSerializer.Deserialize<AuthResponseDTO>(responseContent, new JsonSerializerOptions                {                    PropertyNameCaseInsensitive = true                });                if (result != null && !string.IsNullOrEmpty(result.Token))                {                    _tokenService.StoreTokens(result.Token, result.RefreshToken);                    _logger.LogInformation("Token refresh successful");                    return true;                }            }            _logger.LogWarning("Token refresh failed with status: {StatusCode}", response.StatusCode);            return false;        }        catch (Exception ex)        {            _logger.LogError(ex, "Error during token refresh");            return false;        }        finally        {            lock (_refreshLock)            {                _isRefreshing = false;            }        }    }}