using System.Net;using System.Net.Http.Headers;using System.Text;using System.Text.Json;using KCloud.Web.Interfaces;using KCloud.Web.Models.DTO;namespace KCloud.Web.Interceptors;public class AuthTokenDelegatingHandler(    IAuthTokenService tokenService,    IConfiguration configuration,    ILogger<AuthTokenDelegatingHandler> logger)    : DelegatingHandler{    private static readonly object _refreshLock = new();    private static bool _isRefreshing = false;    protected override async Task<HttpResponseMessage> SendAsync(HttpRequestMessage request, CancellationToken cancellationToken)    {        var accessToken = tokenService.GetAccessToken();                if (string.IsNullOrEmpty(accessToken))        {            logger.LogInformation("No access token found, attempting refresh");                        var refreshSuccess = await TryRefreshToken(cancellationToken);            if (refreshSuccess)            {                accessToken = tokenService.GetAccessToken();                logger.LogInformation("Token refreshed successfully");            }            else            {                logger.LogWarning("No access token and refresh failed");                return new HttpResponseMessage(HttpStatusCode.Unauthorized)                {                    Content = new StringContent("Authentication required")                };            }        }        if (!string.IsNullOrEmpty(accessToken))        {            request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", accessToken);        }                var response = await base.SendAsync(request, cancellationToken);                if (response.StatusCode == HttpStatusCode.Unauthorized && !_isRefreshing)        {            logger.LogInformation("Received 401, attempting token refresh");            var refreshSuccess = await TryRefreshToken(cancellationToken);            if (refreshSuccess)            {                logger.LogInformation("Token refreshed, retrying request");                                var newAccessToken = tokenService.GetAccessToken();                if (!string.IsNullOrEmpty(newAccessToken))                {                    request.Headers.Authorization = new AuthenticationHeaderValue("Bearer", newAccessToken);                    response = await base.SendAsync(request, cancellationToken);                }            }            else            {                logger.LogWarning("Token refresh failed, clearing tokens");                tokenService.ClearTokens();            }        }        return response;    }    private async Task<bool> TryRefreshToken(CancellationToken cancellationToken)    {        lock (_refreshLock)        {            if (_isRefreshing) return false;            _isRefreshing = true;        }        try        {            var refreshToken = tokenService.GetRefreshToken();            if (string.IsNullOrEmpty(refreshToken))            {                logger.LogWarning("No refresh token available");                return false;            }                        var gatewayUrl = configuration["Gateway:BaseUrl"] ?? "http://localhost:5178/";                        using var httpClient = new HttpClient();            httpClient.BaseAddress = new Uri(gatewayUrl);            var refreshData = new { RefreshToken = refreshToken };            var json = JsonSerializer.Serialize(refreshData);            var content = new StringContent(json, Encoding.UTF8, "application/json");            var response = await httpClient.PostAsync("/auth/refresh", content, cancellationToken);            if (response.IsSuccessStatusCode)            {                var responseContent = await response.Content.ReadAsStringAsync(cancellationToken);                                var result = JsonSerializer.Deserialize<AuthResponseDTO>(responseContent, new JsonSerializerOptions                {                    PropertyNameCaseInsensitive = true                });                if (result != null && !string.IsNullOrEmpty(result.Token))                {                    tokenService.StoreTokens(result.Token, result.RefreshToken);                    logger.LogInformation("Token refresh successful");                    return true;                }            }            logger.LogWarning("Token refresh failed with status: {StatusCode}", response.StatusCode);            return false;        }        catch (Exception ex)        {            logger.LogError(ex, "Error during token refresh");            return false;        }        finally        {            lock (_refreshLock)            {                _isRefreshing = false;            }        }    }}