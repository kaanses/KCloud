using AutoMapper;using KCloud.Web.Features.Files.Commands;using KCloud.Web.Features.Files.Queries;using KCloud.Web.Models;using KCloud.Web.Models.ViewModel;using MediatR;using Microsoft.AspNetCore.Authorization;using Microsoft.AspNetCore.Mvc;namespace KCloud.Web.Controllers;[Route("[controller]")]public class FileController(IMediator mediator, ILogger<FileController> logger, IMapper mapper)    : Controller{    [HttpGet]    public async Task<IActionResult> Index(        Guid? folderId = null,         string? search = null,         bool isSharedWithMe = false,        bool isTrash = false,                  string? orderBy = null,                 bool descending = true              )    {        var query = new GetUserFilesQuery(folderId, search, isSharedWithMe, isTrash,orderBy, descending);        var result = await mediator.Send(query);        if (!result.IsSuccess)        {            TempData["Error"] = result.Errors.FirstOrDefault() ?? "Failed to load files";            return View(new FilesIndexViewModel());        }        var viewModel = mapper.Map<FilesIndexViewModel>(result.Value);        viewModel.CurrentFolderId = folderId;        viewModel.SearchTerm = search;        viewModel.IsSharedWithMeView = isSharedWithMe;        viewModel.IsTrashView = isTrash;             viewModel.OrderBy = orderBy;                 viewModel.Descending = descending;          return View(viewModel);    }        [HttpPost("upload")]    [ValidateAntiForgeryToken]    public async Task<IActionResult> Upload([FromForm]UploadFileViewModel model)    {        if (!ModelState.IsValid || model.File == null || model.File.Length == 0)        {            return Json(new { success = false, message = "Please select a valid file." });        }        var command = new SaveFileCommand(model.File, model.FolderId);        var result = await mediator.Send(command);        if (!result.IsSuccess)        {            return Json(new             {                 success = false,                 message = result.Errors.FirstOrDefault() ?? "File upload failed."             });        }        return Json(new         {             success = true,             message = $"File '{model.File.FileName}' uploaded successfully!",            fileId = result.Value.Id,            fileName = result.Value.FileName        });    }    [HttpGet("download/{id}")]    public async Task<IActionResult> Download(Guid id, CancellationToken cancellationToken, [FromQuery]bool isPublicAccess = false)    {        if (id == Guid.Empty)        {            TempData["Error"] = "Invalid file ID";            return RedirectToAction("Index");        }                var query = new DownloadFileQuery(id, isPublicAccess);        var result = await mediator.Send(query, cancellationToken);        if (!result.IsSuccess)        {            TempData["Error"] = result.Errors.FirstOrDefault() ?? "Download failed";            return RedirectToAction("Index");        }        var fileResponse = result.Value;            logger.LogInformation("Serving download for file: {FileName} ({FileId})",             fileResponse.FileName, id);            return File(            fileResponse.FileStream,             fileResponse.ContentType,            fileResponse.FileName,            enableRangeProcessing: true        );    }    [HttpPost("update")]    [ValidateAntiForgeryToken]    public async Task<IActionResult> Update([FromBody]UpdateFileViewModel model)    {        if (!ModelState.IsValid)        {            return Json(new { success = false, message = "Invalid data" });        }        var command = new UpdateFileCommand(model.Id, model.FileName, model.FolderId);        var result = await mediator.Send(command);        if (!result.IsSuccess)        {            return Json(new {                 success = false,                 message = result.Errors.FirstOrDefault() ?? "Update failed"             });        }        return Json(new {             success = true,             message = "File updated successfully!"         });    }    [HttpDelete("delete/{id}")]    public async Task<IActionResult> Delete(Guid id, bool hardDelete = false)    {        if (id == Guid.Empty)        {            return Json(new { success = false, message = "Invalid file ID" });        }        var command = new DeleteFileCommand(id, hardDelete);        var result = await mediator.Send(command);        if (!result.IsSuccess)        {            logger.LogError("Delete failed for {FileId}: {Errors}", id, string.Join(", ", result.Errors));            return Json(new { success = false, message = result.Errors.FirstOrDefault() ?? "Failed to delete file" });        }        var message = hardDelete ? "File permanently deleted" : "File moved to trash";        logger.LogInformation("Delete successful for {FileId}: {Message}", id, message);                return Json(new { success = true, message });    }    [HttpPost("share")]    public async Task<IActionResult> ShareFile([FromBody] ShareFileViewModel request)    {        logger.LogInformation("Sharing file {FileId} with {UserCount} users - Permission: {Permission}, ExpiresAt: {ExpiresAt}",             request.FileId, request.UserIds.Count, request.Permission, request.ExpiresAt);                        var command = new ShareFileWithUsersCommand(            request.FileId,            request.UserIds,            request.Permission,            request.ExpiresAt        );        var result = await mediator.Send(command);        if (!result.IsSuccess)        {            logger.LogError("Share file failed for {FileId}: {Errors}",                 request.FileId, string.Join(", ", result.Errors));            return Json(new { success = false, message = result.Errors.FirstOrDefault() ?? "Failed to share file" });        }        logger.LogInformation("File {FileId} shared successfully with {UserCount} users",             request.FileId, request.UserIds.Count);            return Json(new {             success = true,             message = "File shared successfully",            shares = result.Value         });    }    [HttpPost("public-link")]    public async Task<IActionResult> CreatePublicLink([FromBody] CreatePublicLinkViewModel request)    {        logger.LogInformation("Creating public link for file {FileId} - Permission: {Permission}, ExpiresAt: {ExpiresAt}",             request.FileId, request.Permission, request.ExpiresAt);        var command = new CreatePublicLinkCommand(            request.FileId,            request.Permission,            request.ExpiresAt        );        var result = await mediator.Send(command);        if (!result.IsSuccess)        {            logger.LogError("Create public link failed for {FileId}: {Errors}",                 request.FileId, string.Join(", ", result.Errors));            return Json(new { success = false, message = result.Errors.FirstOrDefault() ?? "Failed to create public link" });        }        logger.LogInformation("Public link created successfully for file {FileId}", request.FileId);            return Json(new {             success = true,             message = "Public link created successfully",             share = result.Value         });    }    }