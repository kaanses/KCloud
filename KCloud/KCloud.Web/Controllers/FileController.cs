using AutoMapper;using KCloud.Web.Features.Files.Commands;using KCloud.Web.Features.Files.Queries;using KCloud.Web.Models.ViewModel;using MediatR;using Microsoft.AspNetCore.Authorization;using Microsoft.AspNetCore.Mvc;namespace KCloud.Web.Controllers;[Authorize][Route("[controller]")]public class FileController : Controller{    private readonly IMediator _mediator;    private readonly ILogger<FileController> _logger;    private readonly IMapper _mapper;    public FileController(IMediator mediator, ILogger<FileController> logger, IMapper mapper)    {        _mediator = mediator;        _logger = logger;        _mapper = mapper;    }    [HttpGet]    public async Task<IActionResult> Index(Guid? folderId = null, string? search = null, bool isSharedWithMeFolder = false)    {        var query = new GetUserFilesQuery(folderId, search, isSharedWithMeFolder);        var result = await _mediator.Send(query);        if (!result.IsSuccess)        {            TempData["Error"] = result.Errors.FirstOrDefault() ?? "Failed to load files";            return View(new FilesIndexViewModel());        }        var viewModel = _mapper.Map<FilesIndexViewModel>(result.Value);        viewModel.CurrentFolderId = folderId;        viewModel.SearchTerm = search;        viewModel.IsSharedWithMeView = isSharedWithMeFolder;        return View(viewModel);    }    [HttpGet("shared")]    public async Task<IActionResult> SharedWithMe()    {        var query = new GetUserFilesQuery(null, null, true);        var result = await _mediator.Send(query);        if (!result.IsSuccess)        {            TempData["Error"] = result.Errors.FirstOrDefault() ?? "Failed to load shared files";            return View("Index", new FilesIndexViewModel());        }        var viewModel = _mapper.Map<FilesIndexViewModel>(result.Value);        viewModel.CurrentFolderId = null;        viewModel.CurrentFolderPath = "Shared with Me";        viewModel.IsSharedWithMeView = true;        return View("Index", viewModel);    }    [HttpPost("upload")]    [ValidateAntiForgeryToken]    public async Task<IActionResult> Upload(UploadFileViewModel model)    {        if (!ModelState.IsValid || model.File == null || model.File.Length == 0)        {            return Json(new { success = false, message = "Please select a valid file." });        }        var command = new SaveFileCommand(model.File, model.FolderId);        var result = await _mediator.Send(command);        if (!result.IsSuccess)        {            return Json(new             {                 success = false,                 message = result.Errors.FirstOrDefault() ?? "File upload failed."             });        }        return Json(new         {             success = true,             message = $"File '{model.File.FileName}' uploaded successfully!",            fileId = result.Value.Id,            fileName = result.Value.FileName        });    }    [HttpGet("download/{id}")]    public async Task<IActionResult> Download(Guid id, CancellationToken cancellationToken)    {        if (id == Guid.Empty)        {            TempData["Error"] = "Invalid file ID";            return RedirectToAction("Index");        }        var query = new DownloadFileQuery(id);        var result = await _mediator.Send(query, cancellationToken);        if (!result.IsSuccess)        {            TempData["Error"] = result.Errors.FirstOrDefault() ?? "Download failed";            return RedirectToAction("Index");        }        var fileResponse = result.Value;            _logger.LogInformation("Serving download for file: {FileName} ({FileId})",             fileResponse.FileName, id);            return File(            fileResponse.FileStream,             fileResponse.ContentType,            fileResponse.FileName,            enableRangeProcessing: true        );    }    [HttpDelete("delete/{id}")]    public async Task<IActionResult> Delete(Guid id, bool hardDelete = false)    {        if (id == Guid.Empty)        {            return Json(new { success = false, message = "Invalid file ID" });        }        var command = new DeleteFileCommand(id, hardDelete);        var result = await _mediator.Send(command);        if (!result.IsSuccess)        {            _logger.LogError("Delete failed for {FileId}: {Errors}", id, string.Join(", ", result.Errors));            return Json(new { success = false, message = result.Errors.FirstOrDefault() ?? "Failed to delete file" });        }        var message = hardDelete ? "File permanently deleted" : "File moved to trash";        _logger.LogInformation("Delete successful for {FileId}: {Message}", id, message);                return Json(new { success = true, message });    }}