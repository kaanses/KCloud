using AutoMapper;using KCloud.Web.Features.Files.Commands;using KCloud.Web.Features.Files.Queries;using KCloud.Web.Models;using KCloud.Web.Models.ViewModel;using MediatR;using Microsoft.AspNetCore.Authorization;using Microsoft.AspNetCore.Mvc;using Microsoft.Extensions.Localization;namespace KCloud.Web.Controllers;[Route("[controller]")][Authorize]public class FileController(IMediator mediator, ILogger<FileController> logger, IMapper mapper, IStringLocalizer<FileController> localizer)    : BaseController{    [HttpGet]    [AllowAnonymous]    public async Task<IActionResult> Index(        Guid? folderId = null,         string? search = null,         bool isSharedWithMe = false,        bool isTrash = false,                  string? orderBy = null,                 bool descending = true              )    {        var query = new GetUserFilesQuery(folderId, search, isSharedWithMe, isTrash, orderBy, descending);        var result = await mediator.Send(query);        if (!result.IsSuccess)        {            TempData["Error"] = string.Join(", ", result.Errors);            return View(new FilesIndexViewModel());        }        var viewModel = mapper.Map<FilesIndexViewModel>(result.Value);        viewModel.CurrentFolderId = folderId;        viewModel.SearchTerm = search;        viewModel.IsSharedWithMeView = isSharedWithMe;        viewModel.IsTrashView = isTrash;             viewModel.OrderBy = orderBy;                 viewModel.Descending = descending;          return View(viewModel);    }        [HttpPost("upload")]    public async Task<IActionResult> Upload([FromForm]UploadFileViewModel model)    {        if (!ModelState.IsValid || model.File == null || model.File.Length == 0)        {            return Json(new { success = false, message = localizer["PleaseSelectValidFile"] });        }        var command = new SaveFileCommand(model.File, model.FolderId);        var result = await mediator.Send(command);        return HandleResult(result, localizer["FileUploadedSuccessfully", model.File.FileName]);    }    [HttpGet("download/{id}")]    public async Task<IActionResult> Download(Guid id, CancellationToken cancellationToken, [FromQuery]bool isPublicAccess = false)    {        if (id == Guid.Empty)        {            TempData["Error"] = localizer["InvalidFileId"];            return RedirectToAction("Index");        }                var query = new DownloadFileQuery(id, isPublicAccess);        var result = await mediator.Send(query, cancellationToken);        if (!result.IsSuccess)        {            TempData["Error"] = string.Join(", ", result.Errors);            return RedirectToAction("Index");        }        var fileResponse = result.Value;            logger.LogInformation("Serving download for file: {FileName} ({FileId})",             fileResponse.FileName, id);            return File(            fileResponse.FileStream,             fileResponse.ContentType,            fileResponse.FileName,            enableRangeProcessing: true        );    }    [HttpPost("update")]    public async Task<IActionResult> Update([FromBody]UpdateFileViewModel model)    {        if (!ModelState.IsValid)        {            return Json(new { success = false, message = localizer["InvalidData"] });        }        var command = new UpdateFileCommand(model.Id, model.FileName, model.FolderId);        var result = await mediator.Send(command);        return HandleResult(result, localizer["FileUpdatedSuccessfully"]);    }    [HttpDelete("delete/{id}")]    public async Task<IActionResult> Delete(Guid id, bool isHardDelete)    {        if (id == Guid.Empty)        {            return Json(new { success = false, message = localizer["InvalidFileId"] });        }        logger.LogInformation("Delete request for file {FileId} - HardDelete: {HardDelete}", id, isHardDelete);        var command = new DeleteFileCommand(id, isHardDelete);        var result = await mediator.Send(command);        var message = isHardDelete ? localizer["FilePermanentlyDeleted"] : localizer["FileMovedToTrash"];        return HandleResult(result, message);    }    [HttpPost("share")]    public async Task<IActionResult> ShareFile([FromBody] ShareFileViewModel request)    {        logger.LogInformation("Sharing file {FileId} with {UserCount} users - Permission: {Permission}, ExpiresAt: {ExpiresAt}",             request.FileId, request.UserIds.Count, request.Permission, request.ExpiresAt);                var command = new ShareFileWithUsersCommand(            request.FileId,            request.UserIds,            request.Permission,            request.ExpiresAt        );        var result = await mediator.Send(command);        return HandleResult(result, localizer["FileSharedSuccessfully"]);    }    [HttpPost("public-link")]    public async Task<IActionResult> CreatePublicLink([FromBody] CreatePublicLinkViewModel request)    {        logger.LogInformation("Creating public link for file {FileId} - Permission: {Permission}, ExpiresAt: {ExpiresAt}",             request.FileId, request.Permission, request.ExpiresAt);        var command = new CreatePublicLinkCommand(            request.FileId,            request.Permission,            request.ExpiresAt        );        var result = await mediator.Send(command);        return HandleResult(result, localizer["PublicLinkCreatedSuccessfully"]);    }    [HttpPost("restore/{id?}")]    public async Task<IActionResult> RestoreFile(Guid? id, bool restoreAll = false)    {        logger.LogInformation("Restoring file(s) with FileId: {FileId}, RestoreAll: {RestoreAll}",             id, restoreAll);        var command = new RestoreFileCommand(id, restoreAll);        var result = await mediator.Send(command);        var message = restoreAll ? localizer["AllFilesRestoredSuccessfully"] : localizer["FileRestoredSuccessfully"];        return HandleResult(result, message);    }    [HttpPost("empty-trash")]    public async Task<IActionResult> EmptyTrash()    {        logger.LogInformation("Emptying trash");        var command = new EmptyTrashCommand();        var result = await mediator.Send(command);        return HandleResult(result, localizer["TrashEmptiedSuccessfully"]);    }}