using System.Text;using System.Text.Json;using Ardalis.Result;using KCloud.Web.Features.Files.Commands;using KCloud.Web.Features.Folders.Commands;using KCloud.Web.Interfaces;using KCloud.Web.Models.DTO;using MediatR;namespace KCloud.Web.Features.Folders.CommandHandlers;public class DeleteFolderCommandHandler(    IHttpClientFactory httpClientFactory,    ILogger<DeleteFolderCommandHandler> logger,    IParseServerResponseService parseServerResponseService,    IMediator mediator)    : IRequestHandler<DeleteFolderCommand, Result>{    private readonly JsonSerializerOptions _jsonOptions = new()    {        PropertyNameCaseInsensitive = true,        PropertyNamingPolicy = JsonNamingPolicy.CamelCase    };    public async Task<Result> Handle(DeleteFolderCommand request, CancellationToken cancellationToken)    {        try        {            var httpClient = httpClientFactory.CreateClient("KCloudGateway");                        var deleteRequest = new            {                 request.Id,                 request.DeleteContents,                 request.MoveContentsToParent,                  request.MoveContentsToRoot            };                        var json = JsonSerializer.Serialize(deleteRequest, _jsonOptions);            var content = new StringContent(json, Encoding.UTF8, "application/json");                        logger.LogInformation("Deleting folder {FolderId} with DeleteContents={DeleteContents}, MoveToParent={MoveToParent}, MoveToRoot={MoveToRoot}",                 request.Id, request.DeleteContents, request.MoveContentsToParent, request.MoveContentsToRoot);            // Use POST instead of DELETE with body            var response = await httpClient.PostAsync("/folder/delete-folder", content, cancellationToken);            var responseContent = await response.Content.ReadAsStringAsync(cancellationToken);            if (response.IsSuccessStatusCode)            {                var successResult = await parseServerResponseService.ParseSuccessResponse<DeleteFolderResponseDTO>(responseContent);                                if (!successResult.IsSuccess)                {                    return Result.Error("Failed to parse server response");                }                var deleteResponse = successResult.Value;                                if (request.DeleteContents && deleteResponse.DeletedFileIds?.Any() == true)                {                    logger.LogInformation("Deleting {FileCount} files from storage for folder {FolderId}",                         deleteResponse.DeletedFileIds.Count, request.Id);                                        var storageDeletionTasks = deleteResponse.DeletedFileIds.Select(fileId =>                         mediator.Send(new DeleteFileStorageCommand(fileId), cancellationToken)                    );                    var storageDeletionResults = await Task.WhenAll(storageDeletionTasks);                                        var failedDeletions = storageDeletionResults.Where(r => !r.IsSuccess).ToList();                    if (failedDeletions.Any())                    {                        logger.LogWarning("Failed to delete {FailedCount} files from storage for folder {FolderId}",                             failedDeletions.Count, request.Id);                    }                }                logger.LogInformation("Successfully deleted folder {FolderId}", request.Id);                return Result.Success();            }            var errorResult = await parseServerResponseService.ParseErrorResponse<object>(                responseContent,                 (int)response.StatusCode);                        return Result.Error(string.Join(", ", errorResult.Errors));        }        catch (Exception ex)        {            logger.LogError(ex, "Network error during folder deletion for {FolderId}", request.Id);            return Result.Error("Unable to connect to server");        }    }}