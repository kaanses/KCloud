async function showUploadDialog(currentFolderId = null, currentFolderName = null) {    try {        const { value: file } = await Swal.fire({            title: 'Upload File',            html: `                <div class="text-start">                    ${currentFolderName ? `<div class="alert alert-info">                        <i class="bi bi-folder me-2"></i>Uploading to: <strong>${currentFolderName}</strong>                    </div>` : ''}                    <label for="swal-file" class="form-label">Choose File(s)</label>                    <input type="file" id="swal-file" class="form-control" multiple accept="*/*">                    <div class="form-text mt-2">Maximum file size: 200 mb per file</div>                </div>            `,            focusConfirm: false,            showCancelButton: true,            confirmButtonText: '<i class="bi bi-cloud-upload me-1"></i> Upload',            cancelButtonText: 'Cancel',            customClass: {                popup: 'swal-wide'            },            preConfirm: () => {                const fileInput = document.getElementById('swal-file');                if (!fileInput.files.length) {                    Swal.showValidationMessage('Please select at least one file');                    return false;                }                return fileInput.files;            }        });        if (file) {            await uploadFiles(file, currentFolderId);        }    } catch (error) {        console.error('Upload dialog error:', error);        Swal.fire({            icon: 'error',            title: 'Error',            text: 'Failed to show upload dialog'        });    }}async function uploadFiles(files, folderId = null) {    // Show loading dialog    Swal.fire({        title: 'Uploading...',        html: `            <div class="progress mb-3">                <div class="progress-bar progress-bar-striped progress-bar-animated"                      role="progressbar" style="width: 0%" id="upload-progress"></div>            </div>            <div id="upload-status">Preparing upload...</div>        `,        allowOutsideClick: false,        allowEscapeKey: false,        showConfirmButton: false,        didOpen: () => {            Swal.showLoading();        }    });    try {        // Prepare FormData        const formData = new FormData();        // Add files        if (files.length === 1) {            formData.append('File', files[0]);        } else {            Array.from(files).forEach(file => {                formData.append('Files', file);            });        }        // Add folder ID if provided        if (folderId && folderId.trim() !== '' && folderId !== 'undefined') {            formData.append('FolderId', folderId.trim());        }        // Add anti-forgery token        const token = document.querySelector('input[name="__RequestVerificationToken"]')?.value;        if (token) {            formData.append('__RequestVerificationToken', token);        }        // Debug logging        console.log('Uploading files:', Array.from(files).map(f => f.name));        console.log('Target folder:', folderId || 'Root');        // Update status        document.getElementById('upload-status').textContent = `Uploading ${files.length} file(s)...`;        // Send request        const response = await fetch('/File/upload', {            method: 'POST',            body: formData        });        const result = await response.json();        if (result.success) {            // Success            await Swal.fire({                icon: 'success',                title: 'Upload Successful!',                text: result.message || `${files.length} file(s) uploaded successfully`,                timer: 2000,                showConfirmButton: false            });            // Reload page to show new files            location.reload();        } else {            // Server error            await Swal.fire({                icon: 'error',                title: 'Upload Failed',                text: result.message || 'Failed to upload files',                confirmButtonText: 'OK'            });        }    } catch (error) {        console.error('Upload error:', error);        // Network/unexpected error        await Swal.fire({            icon: 'error',            title: 'Upload Error',            text: 'Network error occurred. Please try again.',            confirmButtonText: 'OK'        });    }}async function showCreateFolderDialog(parentFolderId = null) {    try {        const { value: folderName } = await Swal.fire({            title: 'Create New Folder',            input: 'text',            inputLabel: 'Folder Name',            inputPlaceholder: 'Enter folder name...',            showCancelButton: true,            confirmButtonText: '<i class="bi bi-folder-plus me-1"></i> Create',            cancelButtonText: 'Cancel',            inputValidator: (value) => {                if (!value || !value.trim()) {                    return 'Please enter a folder name';                }                if (value.length > 50 ) {                    return 'Folder name is too long';                }                return null;            }        });        if (folderName) {            await createFolder(folderName.trim(), parentFolderId);        }    } catch (error) {        console.error('Create folder dialog error:', error);        Swal.fire({            icon: 'error',            title: 'Error',            text: 'Failed to show create folder dialog'        });    }}async function createFolder(folderName, parentFolderId = null) {    try {        // Show loading        Swal.fire({            title: 'Creating folder...',            allowOutsideClick: false,            allowEscapeKey: false,            showConfirmButton: false,            didOpen: () => {                Swal.showLoading();            }        });        const requestData = {            Name: folderName,            ParentFolderId: parentFolderId && parentFolderId.trim() !== '' ? parentFolderId.trim() : null        };        const response = await fetch('/Folder/create', {            method: 'POST',            headers: {                'Content-Type': 'application/json',                'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value            },            body: JSON.stringify(requestData)        });        const result = await response.json();        if (result.success) {            await Swal.fire({                icon: 'success',                title: 'Folder Created!',                text: result.message || `Folder "${folderName}" created successfully`,                timer: 2000,                showConfirmButton: false            });            location.reload();        } else {            await Swal.fire({                icon: 'error',                title: 'Failed to Create Folder',                text: result.message || 'Could not create folder',                confirmButtonText: 'OK'            });        }    } catch (error) {        console.error('Create folder error:', error);        await Swal.fire({            icon: 'error',            title: 'Error',            text: 'Network error occurred. Please try again.',            confirmButtonText: 'OK'        });    }}function showAlert(type, message) {    const iconMap = {        'success': 'success',        'danger': 'error',        'error': 'error',        'warning': 'warning',        'info': 'info'    };    Swal.fire({        toast: true,        position: 'top-end',        icon: iconMap[type] || 'info',        title: message,        showConfirmButton: false,        timer: 4000,        timerProgressBar: true,        didOpen: (toast) => {            toast.addEventListener('mouseenter', Swal.stopTimer)            toast.addEventListener('mouseleave', Swal.resumeTimer)        }    });}async function renameFile(fileId, currentName) {    try {        const { value: newName } = await Swal.fire({            title: '<i class="bi bi-pencil me-2"></i>Rename File',            input: 'text',            inputValue: currentName,            inputLabel: 'File Name',            showCancelButton: true,            confirmButtonText: '<i class="bi bi-check me-1"></i> Rename',            cancelButtonText: '<i class="bi bi-x-circle me-1"></i> Cancel',            inputValidator: (value) => {                if (!value || !value.trim()) {                    return 'Please enter a file name';                }                if (value.length > 255) {                    return 'File name is too long';                }                return null;            }        });        if (newName && newName.trim() !== currentName) {            await performFileRename(fileId, newName.trim());        }    } catch (error) {        console.error('Rename dialog error:', error);        showAlert('error', 'Failed to show rename dialog');    }}async function performFileRename(fileId, newName) {    try {        Swal.fire({            title: 'Renaming file...',            allowOutsideClick: false,            allowEscapeKey: false,            showConfirmButton: false,            didOpen: () => {                Swal.showLoading();            }        });        const response = await fetch('/file/update', {            method: 'POST',            headers: {                'Content-Type': 'application/json',                'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value            },            body: JSON.stringify({                Id: fileId,                FileName: newName,                FolderId: null            })        });        const result = await response.json();        if (result.success) {            await Swal.fire({                icon: 'success',                title: 'File Renamed!',                text: result.message || 'File renamed successfully',                timer: 2000,                showConfirmButton: false            });            location.reload();        } else {            await Swal.fire({                icon: 'error',                title: 'Rename Failed',                text: result.message || 'Could not rename file',                confirmButtonText: 'OK'            });        }    } catch (error) {        console.error('Rename error:', error);        await Swal.fire({            icon: 'error',            title: 'Error',            text: 'Network error occurred. Please try again.',            confirmButtonText: 'OK'        });    }}// Updated delete function with trash/hard delete logicasync function deleteFile(event, fileId, fileName, isTrashView = false) {    try {                if (isTrashView) {            // In trash view - ask for permanent deletion            const result = await Swal.fire({                title: 'Permanently Delete File?',                html: `Are you sure you want to <strong>permanently delete</strong> <strong>"${fileName}"</strong>?<br><br><span class="text-danger"><i class="bi bi-exclamation-triangle me-1"></i>This action cannot be undone!</span>`,                icon: 'error',                showCancelButton: true,                confirmButtonColor: '#dc3545',                cancelButtonColor: '#6c757d',                confirmButtonText: '<i class="bi bi-trash-fill me-1"></i> Delete Forever',                cancelButtonText: '<i class="bi bi-x-circle me-1"></i> Cancel'            });            if (result.isConfirmed) {                await performHardDelete(event, fileId, fileName);            }        } else {            // In normal view - ask for trash or hard delete            const result = await Swal.fire({                title: 'Delete File?',                html: `What would you like to do with <strong>"${fileName}"</strong>?`,                icon: 'warning',                showCancelButton: true,                showDenyButton: true,                confirmButtonColor: '#ffc107',                denyButtonColor: '#dc3545',                cancelButtonColor: '#6c757d',                confirmButtonText: '<i class="bi bi-trash me-1"></i> Move to Trash',                denyButtonText: '<i class="bi bi-trash-fill me-1"></i> Delete Forever',                cancelButtonText: '<i class="bi bi-x-circle me-1"></i> Cancel'            });            if (result.isConfirmed) {                await performSoftDelete(event, fileId, fileName);            } else if (result.isDenied) {                // Confirm permanent deletion                const confirmResult = await Swal.fire({                    title: 'Are you absolutely sure?',                    html: `<strong>"${fileName}"</strong> will be permanently deleted and cannot be recovered.`,                    icon: 'error',                    showCancelButton: true,                    confirmButtonColor: '#dc3545',                    cancelButtonColor: '#6c757d',                    confirmButtonText: 'Yes, delete forever',                    cancelButtonText: 'Cancel'                });                if (confirmResult.isConfirmed) {                    await performHardDelete(event, fileId, fileName);                }            }        }    } catch (error) {        console.error('Delete dialog error:', error);        showAlert('error', 'Failed to show delete dialog');    }}// Soft delete (move to trash)async function performSoftDelete(event, fileId, fileName) {    const fileCard = event.target.closest('.col-md-3, .col-sm-4, .col-6');    try {        if (fileCard) {            fileCard.style.opacity = '0.6';            fileCard.style.pointerEvents = 'none';        }        const response = await fetch(`/File/delete/${fileId}`, {            method: 'DELETE',            headers: {                'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value            }        });        const result = await response.json();        if (result.success) {            if (fileCard) {                fileCard.style.transition = 'opacity 0.3s ease, transform 0.3s ease';                fileCard.style.opacity = '0';                fileCard.style.transform = 'scale(0.8)';                setTimeout(() => fileCard.remove(), 300);            }            showAlert('success', result.message || 'File moved to trash');        } else {            if (fileCard) {                fileCard.style.opacity = '1';                fileCard.style.pointerEvents = 'auto';            }            showAlert('error', result.message || 'Failed to delete file');        }    } catch (error) {        console.error('Soft delete error:', error);        if (fileCard) {            fileCard.style.opacity = '1';            fileCard.style.pointerEvents = 'auto';        }        showAlert('error', 'Network error occurred. Please try again.');    }}// Hard delete (permanent)async function performHardDelete(event, fileId, fileName) {    const fileCard = event.target.closest('.col-md-3, .col-sm-4, .col-6');    try {        if (fileCard) {            fileCard.style.opacity = '0.6';            fileCard.style.pointerEvents = 'none';        }        const response = await fetch(`/File/delete/${fileId}?hardDelete=true`, {            method: 'DELETE',            headers: {                'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value            },            body: JSON.stringify({                FileId: fileId,                EmptyTrash: false            })        });        const result = await response.json();        if (result.success) {            if (fileCard) {                fileCard.style.transition = 'opacity 0.3s ease, transform 0.3s ease';                fileCard.style.opacity = '0';                fileCard.style.transform = 'scale(0.8)';                setTimeout(() => fileCard.remove(), 300);            }            showAlert('success', result.message || 'File permanently deleted');        } else {            if (fileCard) {                fileCard.style.opacity = '1';                fileCard.style.pointerEvents = 'auto';            }            showAlert('error', result.message || 'Failed to delete file permanently');        }    } catch (error) {        console.error('Hard delete error:', error);        if (fileCard) {            fileCard.style.opacity = '1';            fileCard.style.pointerEvents = 'auto';        }        showAlert('error', 'Network error occurred. Please try again.');    }}// Restore file from trashasync function restoreFile(event, fileId, fileName) {    const fileCard = event.target.closest('.col-md-3, .col-sm-4, .col-6');    try {        if (fileCard) {            fileCard.style.opacity = '0.6';            fileCard.style.pointerEvents = 'none';        }        const response = await fetch(`/File/restore/${fileId}`, {            method: 'POST',            headers: {                'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value            }        });        const result = await response.json();        if (result.success) {            if (fileCard) {                fileCard.style.transition = 'opacity 0.3s ease, transform 0.3s ease';                fileCard.style.opacity = '0';                fileCard.style.transform = 'scale(0.8)';                setTimeout(() => fileCard.remove(), 300);            }            showAlert('success', result.message || 'File restored successfully');        } else {            if (fileCard) {                fileCard.style.opacity = '1';                fileCard.style.pointerEvents = 'auto';            }            showAlert('error', result.message || 'Failed to restore file');        }    } catch (error) {        console.error('Restore error:', error);        if (fileCard) {            fileCard.style.opacity = '1';            fileCard.style.pointerEvents = 'auto';        }        showAlert('error', 'Network error occurred. Please try again.');    }}// Restore all files from trashasync function restoreAllFiles() {    try {        const result = await Swal.fire({            title: 'Restore All Files?',            text: 'Are you sure you want to restore all files from trash?',            icon: 'question',            showCancelButton: true,            confirmButtonColor: '#198754',            cancelButtonColor: '#6c757d',            confirmButtonText: '<i class="bi bi-arrow-counterclockwise me-1"></i> Restore All',            cancelButtonText: 'Cancel'        });        if (!result.isConfirmed) return;        const btn = document.getElementById('restoreAllBtn');        const originalText = btn?.innerHTML;        if (btn) {            btn.disabled = true;            btn.innerHTML = '<i class="spinner-border spinner-border-sm me-1"></i>Restoring...';        }        const response = await fetch('/File/restore?isRestoreAll=true', {            method: 'POST',            headers: {                'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value            }        });        const responseResult = await response.json();        if (responseResult.success) {            location.reload(); // Refresh to show empty trash        } else {            showAlert('error', responseResult.message || 'Failed to restore files');        }    } catch (error) {        console.error('Restore all error:', error);        showAlert('error', 'Network error occurred');    } finally {        const btn = document.getElementById('restoreAllBtn');        if (btn && originalText) {            btn.disabled = false;            btn.innerHTML = originalText;        }    }}async function renameFolder(folderId, currentName) {    try {        const { value: newName } = await Swal.fire({            title: '<i class="bi bi-folder me-2"></i>Rename Folder',            input: 'text',            inputValue: currentName,            inputLabel: 'Folder Name',            showCancelButton: true,            confirmButtonText: '<i class="bi bi-check me-1"></i> Rename',            cancelButtonText: '<i class="bi bi-x-circle me-1"></i> Cancel',            inputValidator: (value) => {                if (!value || !value.trim()) {                    return 'Please enter a folder name';                }                if (value.length > 100) {                    return 'Folder name is too long';                }                if (/[<>:"/\\|?*]/.test(value)) {                    return 'Folder name contains invalid characters';                }                return null;            }        });        if (newName && newName.trim() !== currentName) {            Swal.fire({                title: 'Renaming folder...',                allowOutsideClick: false,                allowEscapeKey: false,                showConfirmButton: false,                didOpen: () => Swal.showLoading()            });            const response = await fetch('/Folder/update', {                method: 'POST',                headers: {                    'Content-Type': 'application/json',                    'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value                },                body: JSON.stringify({                    Id: folderId,                    Name: newName.trim()                })            });            const result = await response.json();            if (result.success) {                await Swal.fire({                    icon: 'success',                    title: 'Folder Renamed!',                    text: result.message,                    timer: 2000,                    showConfirmButton: false                });                location.reload();            } else {                await Swal.fire({                    icon: 'error',                    title: 'Rename Failed',                    text: result.message,                    confirmButtonText: 'OK'                });            }        }    } catch (error) {        console.error('Rename folder error:', error);        await Swal.fire({            icon: 'error',            title: 'Error',            text: 'Network error occurred. Please try again.',            confirmButtonText: 'OK'        });    }}async function deleteFolder(event, folderId, folderName) {    try {        // Get folder details to check content AND get parent folder ID        const detailsResponse = await fetch('/Folder/details', {            method: 'POST',            headers: {                'Content-Type': 'application/json',                'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value            },            body: JSON.stringify({                Id: folderId            })        });        const detailsResult = await detailsResponse.json();        if (!detailsResult.success) {            await Swal.fire({                icon: 'error',                title: 'Error',                text: detailsResult.message || 'Failed to get folder details',                confirmButtonText: 'OK'            });            return;        }        const folderDetails = detailsResult.data || detailsResult.value || detailsResult;        const fileCount = folderDetails.fileCount || 0;        const subFolderCount = folderDetails.subFolderCount || 0;        const parentFolderId = folderDetails.parentFolderId; // Get parent folder ID        const isEmpty = fileCount === 0 && subFolderCount === 0;        // If folder is empty, proceed with simple delete        if (isEmpty) {            const confirmed = await Swal.fire({                title: `Delete "${folderName}"?`,                text: 'This folder is empty and will be deleted permanently.',                icon: 'warning',                showCancelButton: true,                confirmButtonColor: '#dc3545',                cancelButtonColor: '#6c757d',                confirmButtonText: '<i class="bi bi-trash me-1"></i> Delete',                cancelButtonText: '<i class="bi bi-x-circle me-1"></i> Cancel'            });            if (confirmed.isConfirmed) {                await performFolderDeletion(event, folderId, folderName, 'deleteAll');            }            return;        }        // If folder has content, show options (now with parent folder ID)        const action = await showFolderDeletionOptionsDialog(folderName, fileCount, subFolderCount, parentFolderId);        if (action) {            await performFolderDeletion(event, folderId, folderName, action);        }    } catch (error) {        console.error('Delete folder error:', error);        await Swal.fire({            icon: 'error',            title: 'Error',            text: 'Network error occurred. Please try again.',            confirmButtonText: 'OK'        });    }}async function showFolderDeletionOptionsDialog(folderName, fileCount, subFolderCount, parentFolderId = null) {    const contentDescription = [];    if (fileCount > 0) contentDescription.push(`${fileCount} file(s)`);    if (subFolderCount > 0) contentDescription.push(`${subFolderCount} subfolder(s)`);    // Build the move to parent option conditionally    const moveToParentOption = parentFolderId ? `        <div class="form-check mb-2">            <input class="form-check-input" type="radio" name="deleteAction" id="moveToParent" value="moveToParent">            <label class="form-check-label" for="moveToParent">                <i class="bi bi-arrow-up me-2"></i><strong>Move to parent folder</strong> (keep contents, move them up one level)            </label>        </div>    ` : '';    const { value: action } = await Swal.fire({        title: `Delete "${folderName}"?`,        html: `            <div class="text-start">                <p>This folder contains <strong>${contentDescription.join(' and ')}</strong>.</p>                <p class="mb-3">What would you like to do with the contents?</p>                                <div class="form-check mb-2">                    <input class="form-check-input" type="radio" name="deleteAction" id="deleteAll" value="deleteAll">                    <label class="form-check-label text-danger" for="deleteAll">                        <i class="bi bi-trash me-2"></i><strong>Delete everything</strong> (contents will be permanently deleted)                    </label>                </div>                                ${moveToParentOption}                                <div class="form-check mb-3">                    <input class="form-check-input" type="radio" name="deleteAction" id="moveToRoot" value="moveToRoot">                    <label class="form-check-label" for="moveToRoot">                        <i class="bi bi-house me-2"></i><strong>Move to root</strong> (keep contents, move them to main folder)                    </label>                </div>            </div>        `,        showCancelButton: true,        confirmButtonText: '<i class="bi bi-check me-1"></i> Proceed',        cancelButtonText: '<i class="bi bi-x-circle me-1"></i> Cancel',        customClass: {            popup: 'swal-wide'        },        preConfirm: () => {            const selectedAction = document.querySelector('input[name="deleteAction"]:checked');            if (!selectedAction) {                Swal.showValidationMessage('Please select an option');                return false;            }            return selectedAction.value;        }    });    return action;}async function performFolderDeletion(event, folderId, folderName, action) {    const folderCard = event.target.closest('.col-md-3, .col-sm-4, .col-6');    try {        // Show loading on card        if (folderCard) {            folderCard.style.opacity = '0.6';            folderCard.style.pointerEvents = 'none';        }        Swal.fire({            title: 'Deleting folder...',            allowOutsideClick: false,            allowEscapeKey: false,            showConfirmButton: false,            didOpen: () => Swal.showLoading()        });        // Convert action to boolean flags        const deleteContents = action === 'deleteAll';        const moveContentsToParent = action === 'moveToParent';        const moveContentsToRoot = action === 'moveToRoot';        const response = await fetch('/Folder/delete', {            method: 'POST',             headers: {                'Content-Type': 'application/json',                'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value            },            body: JSON.stringify({                Id: folderId,                DeleteContents: deleteContents,                MoveContentsToParent: moveContentsToParent,                MoveContentsToRoot: moveContentsToRoot            })        });        const result = await response.json();        if (result.success) {            await handleSuccessfulDeletion(event, folderName, result.message);        } else {            // Restore card on error            if (folderCard) {                folderCard.style.opacity = '1';                folderCard.style.pointerEvents = 'auto';            }            await Swal.fire({                icon: 'error',                title: 'Delete Failed',                text: result.message,                confirmButtonText: 'OK'            });        }    } catch (error) {        console.error('Delete folder error:', error);        // Restore card on error        if (folderCard) {            folderCard.style.opacity = '1';            folderCard.style.pointerEvents = 'auto';        }        await Swal.fire({            icon: 'error',            title: 'Error',            text: 'Network error occurred. Please try again.',            confirmButtonText: 'OK'        });    }}async function handleSuccessfulDeletion(event, folderName, message) {    const folderCard = event.target.closest('.col-md-3, .col-sm-4, .col-6');    // Animate card removal    if (folderCard) {        folderCard.style.transition = 'opacity 0.3s ease, transform 0.3s ease';        folderCard.style.opacity = '0';        folderCard.style.transform = 'scale(0.8)';        setTimeout(() => {            folderCard.remove();        }, 300);    }    await Swal.fire({        icon: 'success',        title: 'Folder Deleted!',        text: message || `Folder "${folderName}" deleted    successfully.`,        timer: 2000,        showConfirmButton: false    });}async function emptyTrash() {    if (!confirm('Are you sure you want to permanently delete all items in trash? This action cannot be undone.')) {        return;    }    const btn = document.getElementById('emptyTrashBtn');    const originalText = btn.innerHTML;    btn.disabled = true;    btn.innerHTML = '<i class="spinner-border spinner-border-sm me-1"></i>Emptying...';    try {        const response = await fetch('/File/empty-trash', {            method: 'POST',            headers: {                'Content-Type': 'application/json',                'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value            }        });        const result = await response.json();        if (result.success) {            location.reload();        } else {            alert(result.message || 'Failed to empty trash');        }    } catch (error) {        alert('Network error occurred');    } finally {        btn.disabled = false;        btn.innerHTML = originalText;    }}