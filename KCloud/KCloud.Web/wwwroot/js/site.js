const KCloudModal = {    baseConfig: {        background: 'linear-gradient(145deg, rgba(41, 41, 41, 0.98), rgba(19, 6, 35, 0.95))',        backdrop: `            rgba(0, 0, 0, 0.8)            backdrop-filter: blur(10px);            -webkit-backdrop-filter: blur(10px);        `,        customClass: {            popup: 'kcloud-modal',            title: 'kcloud-modal-title',            htmlContainer: 'kcloud-modal-content',            confirmButton: 'kcloud-btn-primary',            cancelButton: 'kcloud-btn-outline'        },        buttonsStyling: false, // Use our custom button classes        showClass: {            popup: 'animate__animated animate__fadeInUp animate__faster'        },        hideClass: {            popup: 'animate__animated animate__fadeOutDown animate__faster'        }    },    // Method to show modal with base styling + custom options    show(options = {}) {        const config = {            ...this.baseConfig,            ...options,            customClass: {                ...this.baseConfig.customClass,                ...(options.customClass || {})            }        };        return Swal.fire(config);    }};async function renameFile(fileId, currentName) {    try {        const { value: newName } = await KCloudModal.show({            title: '<i class="bi bi-pencil me-2"></i>Rename File',            html: `                <div class="kcloud-form">                    <div class="kcloud-form-group">                        <label for="kcloud-rename-input" class="kcloud-form-label">                            File Name                        </label>                        <div class="kcloud-input-wrapper">                            <i class="bi bi-file-earmark kcloud-input-icon"></i>                            <input type="text" id="kcloud-rename-input" class="kcloud-input"                                    maxlength="255" autocomplete="off">                        </div>                        <div class="kcloud-form-help">                            Enter the new name for your file                        </div>                    </div>                </div>            `,            showCancelButton: true,            confirmButtonText: '<i class="bi bi-check me-1"></i> Rename',            cancelButtonText: '<i class="bi bi-x-circle me-1"></i> Cancel',            focusConfirm: false,            customClass: {                popup: 'kcloud-modal kcloud-rename-modal'            },            didOpen: () => {                const input = document.getElementById('kcloud-rename-input');                // Set value safely after modal opens                input.value = currentName;                input.focus();                // Select filename without extension for easier editing                const lastDotIndex = currentName.lastIndexOf('.');                if (lastDotIndex > 0) {                    input.setSelectionRange(0, lastDotIndex);                } else {                    input.select();                }                // Enter key handler                input.addEventListener('keypress', (e) => {                    if (e.key === 'Enter') {                        Swal.clickConfirm();                    }                });                // Real-time validation feedback                input.addEventListener('input', (e) => {                    const value = e.target.value.trim();                    const wrapper = input.parentElement;                    // Remove existing validation classes                    wrapper.classList.remove('kcloud-input-valid', 'kcloud-input-invalid');                    if (value && value !== currentName && value.length <= 255) {                        wrapper.classList.add('kcloud-input-valid');                    } else if (value.length > 255) {                        wrapper.classList.add('kcloud-input-invalid');                    }                });            },            preConfirm: () => {                const newName = document.getElementById('kcloud-rename-input').value;                const newNameTrimmed = newName.trim();                // Basic checks                if (!newNameTrimmed) {                    Swal.showValidationMessage('Please enter a file name');                    return false;                }                if (newNameTrimmed.length > 255) {                    Swal.showValidationMessage('File name is too long (max 255 characters)');                    return false;                }                if (newNameTrimmed === currentName) {                    Swal.showValidationMessage('Please enter a different name');                    return false;                }                // Block problematic characters that break JavaScript/HTML                const invalidChars = /[<>:"/\\|?*\r\n\t]/g;                if (invalidChars.test(newNameTrimmed)) {                    Swal.showValidationMessage('File name contains invalid characters');                    return false;                }                // Block leading/trailing spaces and dots                if (newNameTrimmed.startsWith(' ') || newNameTrimmed.endsWith(' ') || newNameTrimmed.endsWith('.')) {                    Swal.showValidationMessage('File name cannot start/end with spaces or dots');                    return false;                }                return newNameTrimmed;            }        });        if (newName && newName.trim() !== currentName) {            await performFileRename(fileId, newName.trim(), currentName);        }    } catch (error) {        console.error('Rename dialog error:', error);        showKCloudError('Failed to show rename dialog');    }}async function restoreFile(event, fileId = null, fileName = null, restoreAll = false) {    event.preventDefault();    let title, text, confirmText;    if (restoreAll) {        title = 'Restore All Files?';        text = 'Are you sure you want to restore all files from trash?';        confirmText = 'Yes, restore all!';    } else {        title = 'Restore File?';        text = `Are you sure you want to restore "${fileName}"?`;        confirmText = 'Yes, restore it!';    }    // Show confirmation dialog    const result = await Swal.fire({        title: title,        text: text,        icon: 'question',        showCancelButton: true,        confirmButtonColor: '#d4ff00',        cancelButtonColor: '#6c757d',        confirmButtonText: confirmText,        cancelButtonText: 'Cancel',        background: '#292929',        color: 'white',        customClass: {            confirmButton: 'btn-confirm-custom',            cancelButton: 'btn-cancel-custom'        }    });    if (result.isConfirmed) {        try {            // Get anti-forgery token            const token = document.querySelector('input[name="__RequestVerificationToken"]').value;            // Send restore request            const response = await fetch(`/File/restore/${fileId}?restoreAll=${restoreAll}`, {                method: 'POST',                headers: {                    'RequestVerificationToken': token                }            });            if (!response.ok) {                throw new Error('Network response was not ok');            }            const data = await response.json();            if (data.success) {                // Show success message                const successMessage = restoreAll                    ? "All files have been restored successfully!"                    : `"${fileName}" has been restored successfully!`;                Toastify({                    text: successMessage,                    duration: 3000,                    gravity: "top",                    position: "right",                    backgroundColor: "#d4ff00",                    className: "success-toast",                    style: {                        color: "#130623",                        fontFamily: "'Azeret Mono', monospace",                        fontWeight: "600"                    }                }).showToast();                // Reload the page to update the file list                setTimeout(() => {                    window.location.reload();                }, 1000);            } else {                throw new Error(data.message || 'Failed to restore file');            }        } catch (error) {            console.error('Error:', error);            Swal.fire({                title: 'Error!',                text: 'Failed to restore the file(s). Please try again.',                icon: 'error',                confirmButtonColor: '#ff6b6b',                background: '#292929',                color: 'white'            });        }    }}// Helper function for restore all buttonfunction restoreAllFiles() {    restoreFile(event, null, null, true);}/** * Empty the trash completely */function emptyTrash() {    // Show warning confirmation dialog    Swal.fire({        title: 'Empty Trash?',        text: 'This will permanently delete all files in trash. This action cannot be undone!',        icon: 'warning',        showCancelButton: true,        confirmButtonColor: '#ff6b6b',        cancelButtonColor: '#6c757d',        confirmButtonText: 'Yes, empty trash!',        cancelButtonText: 'Cancel',        background: '#292929',        color: 'white',        customClass: {            confirmButton: 'btn-danger-custom',            cancelButton: 'btn-cancel-custom'        }    }).then((result) => {        if (result.isConfirmed) {            // Second confirmation for safety            Swal.fire({                title: 'Are you absolutely sure?',                text: 'All files will be permanently deleted!',                icon: 'error',                showCancelButton: true,                confirmButtonColor: '#ff6b6b',                cancelButtonColor: '#6c757d',                confirmButtonText: 'DELETE EVERYTHING',                cancelButtonText: 'Cancel',                background: '#292929',                color: 'white'            }).then((finalResult) => {                if (finalResult.isConfirmed) {                    // Create empty form data (no parameters needed)                    const formData = new FormData();                    // Get anti-forgery token                    const token = document.querySelector('input[name="__RequestVerificationToken"]').value;                    formData.append('__RequestVerificationToken', token);                    // Send empty trash request                    fetch('/File/empty-trash', {                        method: 'POST',                        body: formData,                        headers: {                            'RequestVerificationToken': token                        }                    })                        .then(response => {                            if (response.ok) {                                return response.json();                            }                            throw new Error('Network response was not ok');                        })                        .then(data => {                            if (data.success) {                                // Show success message                                Toastify({                                    text: "Trash has been emptied successfully!",                                    duration: 3000,                                    gravity: "top",                                    position: "right",                                    backgroundColor: "#ff6b6b",                                    className: "success-toast",                                    style: {                                        color: "white",                                        fontFamily: "'Azeret Mono', monospace",                                        fontWeight: "600"                                    }                                }).showToast();                                // Reload the page to update the file list                                setTimeout(() => {                                    window.location.reload();                                }, 1000);                            } else {                                throw new Error(data.message || 'Failed to empty trash');                            }                        })                        .catch(error => {                            console.error('Error:', error);                            Swal.fire({                                title: 'Error!',                                text: 'Failed to empty trash. Please try again.',                                icon: 'error',                                confirmButtonColor: '#ff6b6b',                                background: '#292929',                                color: 'white'                            });                        });                }            });        }    });}/** * Clear search and return to normal view */function clearSearch() {    // Get current URL    const url = new URL(window.location);    // Remove search parameter    url.searchParams.delete('search');    // Redirect to URL without search    window.location.href = url.toString();}async function showUploadDialog(currentFolderId = null, currentFolderName = null) {    try {        const { value: file } = await KCloudModal.show({            title: '<i class="bi bi-cloud-upload me-2"></i>Upload Files',            html: `                <div class="kcloud-upload-form">                    ${currentFolderName ? `                        <div class="kcloud-info-badge">                            <i class="bi bi-folder me-2"></i>                            <span>Uploading to: <strong>${currentFolderName}</strong></span>                        </div>                    ` : ''}                                        <div class="kcloud-form-group">                        <label for="kcloud-file-input" class="kcloud-form-label">                            Choose File(s)                        </label>                        <div class="kcloud-file-input-wrapper" id="kcloud-drop-zone">                            <input type="file" id="kcloud-file-input" class="kcloud-file-input"                                    multiple accept="*/*">                            <div class="kcloud-file-input-overlay">                                <i class="bi bi-cloud-upload kcloud-upload-icon"></i>                                <span class="kcloud-drop-text">Click to browse or drag & drop files</span>                                <div class="kcloud-selected-files " id="kcloud-selected-files"></div>                            </div>                        </div>                        <div class="kcloud-form-help">                            Maximum file size: 50 MB per file                        </div>                    </div>                </div>            `,            showCancelButton: true,            confirmButtonText: '<i class="bi bi-cloud-upload me-1"></i> Upload',            cancelButtonText: 'Cancel',            focusConfirm: false,            customClass: {                popup: 'kcloud-modal kcloud-upload-modal'            },            didOpen: () => {                initializeDragAndDrop();            },            preConfirm: () => {                const fileInput = document.getElementById('kcloud-file-input');                if (!fileInput.files.length) {                    Swal.showValidationMessage('Please select at least one file');                    return false;                }                return fileInput.files;            }        });        if (file) {            await uploadFiles(file, currentFolderId);        }    } catch (error) {        console.error('Upload dialog error:', error);        KCloudModal.show({            icon: 'error',            title: 'Upload Error',            text: 'Failed to show upload dialog',            confirmButtonText: 'OK'        });    }}function initializeDragAndDrop() {    const dropZone = document.getElementById('kcloud-drop-zone');    const fileInput = document.getElementById('kcloud-file-input');    const selectedFilesDiv = document.getElementById('kcloud-selected-files');    const dropText = document.querySelector('.kcloud-drop-text');    if (!dropZone || !fileInput) return;    // Handle file selection display    function updateSelectedFiles(files) {        if (files.length === 0) {            selectedFilesDiv.innerHTML = '';            dropText.textContent = 'Click to browse or drag & drop files';            return;        }        const fileList = Array.from(files).map(file => {            const size = formatFileSize(file.size);            return `<div class="kcloud-selected-file">                <i class="bi bi-file-earmark me-2 mt-2"></i>                <span class="mt-2">${file.name}</span>                <small class="text-muted ms-2 mt-2">(${size})</small>            </div>`;        }).join('');        selectedFilesDiv.innerHTML = `            <div class="kcloud-files-list">                <div class="kcloud-files-header mt-2 mb-2">                    <strong>${files.length} file${files.length > 1 ? 's' : ''} selected:</strong>                </div>                ${fileList}            </div>        `;        dropText.textContent = 'Click to change selection';    }    // File input change handler    fileInput.addEventListener('change', (e) => {        updateSelectedFiles(e.target.files);    });    // Prevent default drag behaviors    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {        dropZone.addEventListener(eventName, preventDefaults, false);        document.body.addEventListener(eventName, preventDefaults, false);    });    // Highlight drop zone when item is dragged over it    ['dragenter', 'dragover'].forEach(eventName => {        dropZone.addEventListener(eventName, highlight, false);    });    ['dragleave', 'drop'].forEach(eventName => {        dropZone.addEventListener(eventName, unhighlight, false);    });    // Handle dropped files    dropZone.addEventListener('drop', handleDrop, false);    function preventDefaults(e) {        e.preventDefault();        e.stopPropagation();    }    function highlight(e) {        dropZone.classList.add('kcloud-drag-over');    }    function unhighlight(e) {        dropZone.classList.remove('kcloud-drag-over');    }    function handleDrop(e) {        const dt = e.dataTransfer;        const files = dt.files;        // Update the file input with dropped files        fileInput.files = files;        updateSelectedFiles(files);    }    function formatFileSize(bytes) {        const sizes = ['B', 'KB', 'MB', 'GB'];        if (bytes === 0) return '0 B';        const i = Math.floor(Math.log(bytes) / Math.log(1024));        return Math.round(bytes / Math.pow(1024, i) * 100) / 100 + ' ' + sizes[i];    }}async function uploadFiles(files, folderId = null) {    // Show loading dialog    Swal.fire({        title: 'Uploading...',        html: `            <div class="progress mb-3">                <div class="progress-bar progress-bar-striped progress-bar-animated"                      role="progressbar" style="width: 0%" id="upload-progress"></div>            </div>            <div id="upload-status">Preparing upload...</div>        `,        allowOutsideClick: false,        allowEscapeKey: false,        showConfirmButton: false,        didOpen: () => {            Swal.showLoading();        }    });    try {        // Prepare FormData        const formData = new FormData();        // Add files        if (files.length === 1) {            formData.append('File', files[0]);        } else {            Array.from(files).forEach(file => {                formData.append('Files', file);            });        }        // Add folder ID if provided        if (folderId && folderId.trim() !== '' && folderId !== 'undefined') {            formData.append('FolderId', folderId.trim());        }        // Add anti-forgery token        const token = document.querySelector('input[name="__RequestVerificationToken"]')?.value;        if (token) {            formData.append('__RequestVerificationToken', token);        }        // Debug logging        console.log('Uploading files:', Array.from(files).map(f => f.name));        console.log('Target folder:', folderId || 'Root');        // Update status        document.getElementById('upload-status').textContent = `Uploading ${files.length} file(s)...`;        // Send request        const response = await fetch('/File/upload', {            method: 'POST',            body: formData        });        console.log('Response status:', response.status);        console.log('Response ok:', response.ok);        const result = await response.json();        console.log('Response body:', result);        // Check for success based on HTTP status AND response content        if (response.ok && (result.success !== false)) {            // Success case            let successMessage = 'Upload successful!';            if (result.message) {                successMessage = result.message;            } else if (result.success && result.message) {                successMessage = result.message;            } else {                successMessage = `${files.length} file(s) uploaded successfully`;            }            await Swal.fire({                icon: 'success',                title: 'Upload Successful!',                text: successMessage,                timer: 2000,                showConfirmButton: false            });            // Reload page to show new files            location.reload();        } else {            // Error case - extract error message from various possible formats            let errorMessage = 'Failed to upload files';            // Try different error message sources in priority order            if (result.message) {                // MVC style error response                errorMessage = result.message;            } else if (result.errors) {                // API style error response                if (Array.isArray(result.errors)) {                    errorMessage = result.errors.filter(e => e).join(', ');                } else if (typeof result.errors === 'string') {                    errorMessage = result.errors;                }            } else if (result.validationErrors && Array.isArray(result.validationErrors)) {                // Validation errors                errorMessage = result.validationErrors                    .map(e => e.field ? `${e.field}: ${e.message}` : e.message)                    .join(', ');            } else if (!response.ok) {                // HTTP error fallback                errorMessage = `Server error: ${response.status} ${response.statusText}`;            }            await Swal.fire({                icon: 'error',                title: 'Upload Failed',                text: errorMessage,                confirmButtonText: 'OK'            });        }    } catch (error) {        console.error('Upload error:', error);        // Network/unexpected error        await Swal.fire({            icon: 'error',            title: 'Upload Error',            text: 'Network error occurred. Please try again.',            confirmButtonText: 'OK'        });    }}function formatErrorMessage(message) {    if (!message) return 'An unknown error occurred';    // If message contains multiple errors separated by commas, format as list    if (message.includes(',')) {        const errors = message.split(',').map(err => err.trim());        if (errors.length > 1) {            return `                <ul style="margin: 0; padding-left: 20px;">                    ${errors.map(err => `<li>${err}</li>`).join('')}                </ul>            `;        }    }    return message;}function extractErrorMessage(result) {    // Priority order for extracting error messages    // 1. MVC controller style (result.message)    if (result.message) {        return result.message;    }    // 2. Validation errors (most specific)    if (result.validationErrors && Array.isArray(result.validationErrors) && result.validationErrors.length > 0) {        return result.validationErrors            .map(e => e.field ? `${e.field}: ${e.message}` : e.message)            .join(', ');    }    // 3. General errors array    if (result.errors) {        if (Array.isArray(result.errors)) {            return result.errors.filter(e => e && e.trim()).join(', ');        } else if (typeof result.errors === 'string') {            return result.errors;        }    }    // 4. HTTP status text (if available)    if (result.status && result.statusText) {        return `${result.status}: ${result.statusText}`;    }    // 5. Default fallback    return 'An unknown error occurred during upload';}async function showCreateFolderDialog(parentFolderId = null) {    try {        const { value: folderName } = await KCloudModal.show({            title: '<i class="bi bi-folder-plus me-2"></i>Create New Folder',            html: `                <div class="kcloud-form">                    <div class="kcloud-form-group">                        <label for="kcloud-folder-name" class="kcloud-form-label">                            Folder Name                        </label>                        <div class="kcloud-input-wrapper">                            <i class="bi bi-folder kcloud-input-icon"></i>                            <input type="text" id="kcloud-folder-name" class="kcloud-input"                                    placeholder="Enter folder name..." maxlength="255" autocomplete="off">                        </div>                        <div class="kcloud-form-help">                            Choose a unique name for your folder                        </div>                    </div>                </div>            `,            showCancelButton: true,            confirmButtonText: '<i class="bi bi-folder-plus me-1"></i> Create',            cancelButtonText: 'Cancel',            focusConfirm: false,            customClass: {                popup: 'kcloud-modal kcloud-folder-modal'            },            didOpen: () => {                const input = document.getElementById('kcloud-folder-name');                input.focus();                // Enter key handler                input.addEventListener('keypress', (e) => {                    if (e.key === 'Enter') {                        Swal.clickConfirm();                    }                });            },            preConfirm: () => {                const folderName = document.getElementById('kcloud-folder-name').value.trim();                if (!folderName) {                    Swal.showValidationMessage('Please enter a folder name');                    return false;                }                if (folderName.length < 1) {                    Swal.showValidationMessage('Folder name must be at least 1 character');                    return false;                }                if (folderName.length > 255) {                    Swal.showValidationMessage('Folder name must be less than 255 characters');                    return false;                }                // Check for invalid characters                const invalidChars = /[<>:"/\\|?*]/g;                if (invalidChars.test(folderName)) {                    Swal.showValidationMessage('Folder name contains invalid characters');                    return false;                }                return folderName;            }        });        if (folderName) {            await createFolder(folderName, parentFolderId);        }    } catch (error) {        console.error('Create folder dialog error:', error);        showKCloudError('Failed to show create folder dialog');    }}async function createFolder(folderName, parentFolderId = null) {    try {        // Show loading with KCloud styling        KCloudModal.show({            title: '<i class="bi bi-gear-fill kcloud-spinning me-2"></i>Creating Folder...',            html: `                <div class="kcloud-loading-content">                    <div class="kcloud-loading-spinner"></div>                    <p>Creating "${folderName}"...</p>                </div>            `,            allowOutsideClick: false,            allowEscapeKey: false,            showConfirmButton: false,            customClass: {                popup: 'kcloud-modal kcloud-loading-modal'            }        });        const requestData = {            Name: folderName,            ParentFolderId: parentFolderId && parentFolderId.trim() !== '' ? parentFolderId.trim() : null        };        const response = await fetch('/Folder/create', {            method: 'POST',            headers: {                'Content-Type': 'application/json',                'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value            },            body: JSON.stringify(requestData)        });        const result = await response.json();        if (result.success) {            // Success notification            await KCloudModal.show({                title: '<i class="bi bi-check-circle-fill kcloud-success-icon me-2"></i>Success!',                html: `                    <div class="kcloud-success-content">                        <p>Folder <strong>"${folderName}"</strong> created successfully</p>                    </div>                `,                timer: 2000,                showConfirmButton: false,                customClass: {                    popup: 'kcloud-modal kcloud-success-modal'                }            });            location.reload();        } else {            // Error notification            await KCloudModal.show({                title: '<i class="bi bi-exclamation-triangle-fill kcloud-error-icon me-2"></i>Creation Failed',                html: `                    <div class="kcloud-error-content">                        <p>${result.message || 'Could not create folder'}</p>                    </div>                `,                confirmButtonText: 'Try Again',                customClass: {                    popup: 'kcloud-modal kcloud-error-modal'                }            });        }    } catch (error) {        console.error('Create folder error:', error);        showKCloudError('Network error occurred. Please try again.');    }}// Helper function for consistent error displayfunction showKCloudError(message) {    KCloudModal.show({        title: '<i class="bi bi-exclamation-triangle-fill kcloud-error-icon me-2"></i>Error',        html: `            <div class="kcloud-error-content">                <p>${message}</p>            </div>        `,        confirmButtonText: 'OK',        customClass: {            popup: 'kcloud-modal kcloud-error-modal'        }    });}function showAlert(type, message) {    const iconMap = {        'success': 'success',        'danger': 'error',        'error': 'error',        'warning': 'warning',        'info': 'info'    };    Swal.fire({        toast: true,        position: 'top-end',        icon: iconMap[type] || 'info',        title: message,        showConfirmButton: false,        timer: 4000,        timerProgressBar: true,        didOpen: (toast) => {            toast.addEventListener('mouseenter', Swal.stopTimer)            toast.addEventListener('mouseleave', Swal.resumeTimer)        }    });}async function performFileRename(fileId, newName, oldName) {    try {        // Show loading with file-specific messaging        KCloudModal.show({            title: '<i class="bi bi-gear-fill kcloud-spinning me-2"></i>Renaming File...',            html: `                <div class="kcloud-loading-content">                    <div class="kcloud-loading-spinner"></div>                    <div class="kcloud-rename-progress">                        <p class="kcloud-old-name">From: <span>"${oldName}"</span></p>                        <i class="bi bi-arrow-down kcloud-arrow"></i>                        <p class="kcloud-new-name">To: <span>"${newName}"</span></p>                    </div>                </div>            `,            allowOutsideClick: false,            allowEscapeKey: false,            showConfirmButton: false,            customClass: {                popup: 'kcloud-modal kcloud-loading-modal kcloud-rename-loading'            }        });        const response = await fetch('/file/update', {            method: 'POST',            headers: {                'Content-Type': 'application/json',                'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value            },            body: JSON.stringify({                Id: fileId,                FileName: newName,                FolderId: null            })        });        const result = await response.json();        if (result.success) {            // Success notification            await KCloudModal.show({                title: '<i class="bi bi-check-circle-fill kcloud-success-icon me-2"></i>File Renamed!',                html: `                    <div class="kcloud-success-content">                        <div class="kcloud-rename-success">                            <p>Successfully renamed to:</p>                            <p class="kcloud-new-filename"><strong>"${newName}"</strong></p>                        </div>                    </div>                `,                timer: 2500,                showConfirmButton: false,                customClass: {                    popup: 'kcloud-modal kcloud-success-modal'                }            });            location.reload();        } else {            // Error notification            await KCloudModal.show({                title: '<i class="bi bi-exclamation-triangle-fill kcloud-error-icon me-2"></i>Rename Failed',                html: `                    <div class="kcloud-error-content">                        <p>${result.message || 'Could not rename file'}</p>                        <div class="kcloud-error-details">                            <small>Attempted to rename "${oldName}" to "${newName}"</small>                        </div>                    </div>                `,                confirmButtonText: 'Try Again',                customClass: {                    popup: 'kcloud-modal kcloud-error-modal'                }            });        }    } catch (error) {        console.error('Rename error:', error);        showKCloudError('Network error occurred. Please try again.');    }}// Helper function to escape HTML and prevent XSSasync function deleteFile(event, fileId, fileName, isHardDelete = false) {    try {        const result = await Swal.fire({            title: 'Delete File?',            html: `Are you sure you want to delete <strong>"${fileName}"</strong>?<br><br><small class="text-muted">This will move the file to trash.</small>`,            icon: 'warning',            showCancelButton: true,            confirmButtonColor: '#dc3545',            cancelButtonColor: '#6c757d',            confirmButtonText: '<i class="bi bi-trash me-1"></i> Delete',            cancelButtonText: '<i class="bi bi-x-circle me-1"></i> Cancel'        });        if (result.isConfirmed) {            await performFileDelete(event, fileId, fileName, isHardDelete);        }    } catch (error) {        console.error('Delete dialog error:', error);        showAlert('error', 'Failed to show delete dialog');    }}async function performFileDelete(event, fileId, fileName, isHardDelete) {    const fileCard = event.target.closest('.col-md-3, .col-sm-4, .col-6');    try {        // Show loading on the card        if (fileCard) {            fileCard.style.opacity = '0.6';            fileCard.style.pointerEvents = 'none';        }        const response = await fetch(`/File/delete/${fileId}?isHardDelete=${isHardDelete}`, {            method: 'DELETE',            headers: {                'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value            }        });        const result = await response.json();        if (result.success && !isHardDelete) {            // Animate card removal            if (fileCard) {                fileCard.style.transition = 'opacity 0.3s ease, transform 0.3s ease';                fileCard.style.opacity = '0';                fileCard.style.transform = 'scale(0.8)';                setTimeout(() => {                    fileCard.remove();                }, 300);            }            showAlert('success', result.message || 'File deleted successfully');        } if (result.success && isHardDelete) {            // Animate card removal            if (fileCard) {                fileCard.style.transition = 'opacity 0.3s ease, transform 0.3s ease';                fileCard.style.opacity = '0';                fileCard.style.transform = 'scale(0.8)';                setTimeout(() => {                    fileCard.remove();                }, 300);            }            showAlert('success', result.message || 'File deleted successfully');        }        else {            // Restore card on error            if (fileCard) {                fileCard.style.opacity = '1';                fileCard.style.pointerEvents = 'auto';            }            showAlert('error', result.message || 'Failed to delete file');        }    } catch (error) {        console.error('Delete error:', error);        // Restore card on error        if (fileCard) {            fileCard.style.opacity = '1';            fileCard.style.pointerEvents = 'auto';        }        showAlert('error', 'Network error occurred. Please try again.');    }}async function renameFolder(folderId, currentName) {    try {        const { value: newName } = await Swal.fire({            title: '<i class="bi bi-folder me-2"></i>Rename Folder',            input: 'text',            inputValue: currentName,            inputLabel: 'Folder Name',            showCancelButton: true,            confirmButtonText: '<i class="bi bi-check me-1"></i> Rename',            cancelButtonText: '<i class="bi bi-x-circle me-1"></i> Cancel',            inputValidator: (value) => {                if (!value || !value.trim()) {                    return 'Please enter a folder name';                }                if (value.length > 100) {                    return 'Folder name is too long';                }                if (/[<>:"/\\|?*]/.test(value)) {                    return 'Folder name contains invalid characters';                }                return null;            }        });        if (newName && newName.trim() !== currentName) {            Swal.fire({                title: 'Renaming folder...',                allowOutsideClick: false,                allowEscapeKey: false,                showConfirmButton: false,                didOpen: () => Swal.showLoading()            });            const response = await fetch('/Folder/update', {                method: 'POST',                headers: {                    'Content-Type': 'application/json',                    'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value                },                body: JSON.stringify({                    Id: folderId,                    Name: newName.trim()                })            });            const result = await response.json();            if (result.success) {                await Swal.fire({                    icon: 'success',                    title: 'Folder Renamed!',                    text: result.message,                    timer: 2000,                    showConfirmButton: false                });                location.reload();            } else {                await Swal.fire({                    icon: 'error',                    title: 'Rename Failed',                    text: result.message,                    confirmButtonText: 'OK'                });            }        }    } catch (error) {        console.error('Rename folder error:', error);        await Swal.fire({            icon: 'error',            title: 'Error',            text: 'Network error occurred. Please try again.',            confirmButtonText: 'OK'        });    }}async function deleteFolder(event, folderId, folderName) {    try {        // Get folder details to check content AND get parent folder ID        const detailsResponse = await fetch('/Folder/details', {            method: 'POST',            headers: {                'Content-Type': 'application/json',                'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value            },            body: JSON.stringify({                Id: folderId            })        });        const detailsResult = await detailsResponse.json();        if (!detailsResult.success) {            await Swal.fire({                icon: 'error',                title: 'Error',                text: detailsResult.message || 'Failed to get folder details',                confirmButtonText: 'OK'            });            return;        }        const folderDetails = detailsResult.data || detailsResult.value || detailsResult;        const fileCount = folderDetails.fileCount || 0;        const subFolderCount = folderDetails.subFolderCount || 0;        const parentFolderId = folderDetails.parentFolderId; // Get parent folder ID        const isEmpty = fileCount === 0 && subFolderCount === 0;        // If folder is empty, proceed with simple delete        if (isEmpty) {            const confirmed = await Swal.fire({                title: `Delete "${folderName}"?`,                text: 'This folder is empty and will be deleted permanently.',                icon: 'warning',                showCancelButton: true,                confirmButtonColor: '#dc3545',                cancelButtonColor: '#6c757d',                confirmButtonText: '<i class="bi bi-trash me-1"></i> Delete',                cancelButtonText: '<i class="bi bi-x-circle me-1"></i> Cancel'            });            if (confirmed.isConfirmed) {                await performFolderDeletion(event, folderId, folderName, 'deleteAll');            }            return;        }        // If folder has content, show options (now with parent folder ID)        const action = await showFolderDeletionOptionsDialog(folderName, fileCount, subFolderCount, parentFolderId);        if (action) {            await performFolderDeletion(event, folderId, folderName, action);        }    } catch (error) {        console.error('Delete folder error:', error);        await Swal.fire({            icon: 'error',            title: 'Error',            text: 'Network error occurred. Please try again.',            confirmButtonText: 'OK'        });    }}async function showFolderDeletionOptionsDialog(folderName, fileCount, subFolderCount, parentFolderId = null) {    const contentDescription = [];    if (fileCount > 0) contentDescription.push(`${fileCount} file(s)`);    if (subFolderCount > 0) contentDescription.push(`${subFolderCount} subfolder(s)`);    // Build the move to parent option conditionally    const moveToParentOption = parentFolderId ? `        <div class="form-check mb-2">            <input class="form-check-input" type="radio" name="deleteAction" id="moveToParent" value="moveToParent">            <label class="form-check-label" for="moveToParent">                <i class="bi bi-arrow-up me-2"></i><strong>Move to parent folder</strong> (keep contents, move them up one level)            </label>        </div>    ` : '';    const { value: action } = await Swal.fire({        title: `Delete "${folderName}"?`,        html: `            <div class="text-start">                <p>This folder contains <strong>${contentDescription.join(' and ')}</strong>.</p>                <p class="mb-3">What would you like to do with the contents?</p>                                <div class="form-check mb-2">                    <input class="form-check-input" type="radio" name="deleteAction" id="deleteAll" value="deleteAll">                    <label class="form-check-label text-danger" for="deleteAll">                        <i class="bi bi-trash me-2"></i><strong>Delete everything</strong> (contents will be permanently deleted)                    </label>                </div>                                ${moveToParentOption}                                <div class="form-check mb-3">                    <input class="form-check-input" type="radio" name="deleteAction" id="moveToRoot" value="moveToRoot">                    <label class="form-check-label" for="moveToRoot">                        <i class="bi bi-house me-2"></i><strong>Move to root</strong> (keep contents, move them to main folder)                    </label>                </div>            </div>        `,        showCancelButton: true,        confirmButtonText: '<i class="bi bi-check me-1"></i> Proceed',        cancelButtonText: '<i class="bi bi-x-circle me-1"></i> Cancel',        customClass: {            popup: 'swal-wide'        },        preConfirm: () => {            const selectedAction = document.querySelector('input[name="deleteAction"]:checked');            if (!selectedAction) {                Swal.showValidationMessage('Please select an option');                return false;            }            return selectedAction.value;        }    });    return action;}async function performFolderDeletion(event, folderId, folderName, action) {    const folderCard = event.target.closest('.col-md-3, .col-sm-4, .col-6');    try {        // Show loading on card        if (folderCard) {            folderCard.style.opacity = '0.6';            folderCard.style.pointerEvents = 'none';        }        Swal.fire({            title: 'Deleting folder...',            allowOutsideClick: false,            allowEscapeKey: false,            showConfirmButton: false,            didOpen: () => Swal.showLoading()        });        // Convert action to boolean flags        const deleteContents = action === 'deleteAll';        const moveContentsToParent = action === 'moveToParent';        const moveContentsToRoot = action === 'moveToRoot';        const response = await fetch('/Folder/delete', {            method: 'POST',             headers: {                'Content-Type': 'application/json',                'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value            },            body: JSON.stringify({                Id: folderId,                DeleteContents: deleteContents,                MoveContentsToParent: moveContentsToParent,                MoveContentsToRoot: moveContentsToRoot            })        });        const result = await response.json();        if (result.success) {            await handleSuccessfulDeletion(event, folderName, result.message);        } else {            // Restore card on error            if (folderCard) {                folderCard.style.opacity = '1';                folderCard.style.pointerEvents = 'auto';            }            await Swal.fire({                icon: 'error',                title: 'Delete Failed',                text: result.message,                confirmButtonText: 'OK'            });        }    } catch (error) {        console.error('Delete folder error:', error);        // Restore card on error        if (folderCard) {            folderCard.style.opacity = '1';            folderCard.style.pointerEvents = 'auto';        }        await Swal.fire({            icon: 'error',            title: 'Error',            text: 'Network error occurred. Please try again.',            confirmButtonText: 'OK'        });    }}async function handleSuccessfulDeletion(event, folderName, message) {    const folderCard = event.target.closest('.col-md-3, .col-sm-4, .col-6');    // Animate card removal    if (folderCard) {        folderCard.style.transition = 'opacity 0.3s ease, transform 0.3s ease';        folderCard.style.opacity = '0';        folderCard.style.transform = 'scale(0.8)';        setTimeout(() => {            folderCard.remove();        }, 300);    }    await Swal.fire({        icon: 'success',        title: 'Folder Deleted!',        text: message || `Folder "${folderName}" deleted    successfully.`,        timer: 2000,        showConfirmButton: false    });}async function shareFile(fileId, fileName) {    try {        let selectedUsers = []; // Local to this function        const { value: shareData } = await Swal.fire({            title: 'Share File',            html: `                <div class="text-start">                    <div class="alert alert-info mb-3">                        <i class="bi bi-file-earmark me-2"></i>Sharing: <strong>${fileName}</strong>                    </div>                                        <!-- Quick Actions Section -->                    <div class="mb-4">                        <div class="d-grid">                            <button type="button" class="btn btn-outline-primary" id="createPublicLinkBtn">                                <i class="bi bi-link-45deg me-2"></i>Create Public Link                            </button>                        </div>                    </div>                                        <hr>                    <h6 class="mb-3">Or share with specific users:</h6>                                        <!-- User Search Section -->                    <div class="mb-3">                        <label class="form-label">Search Users</label>                        <div class="input-group">                            <input type="text" id="userSearchInput" class="form-control"                                    placeholder="Type username to search..." autocomplete="off">                            <button type="button" id="searchBtn" class="btn btn-outline-secondary">                                <i class="bi bi-search"></i>                            </button>                        </div>                        <div id="searchResults" class="mt-2 border rounded" style="max-height: 150px; overflow-y: auto; display: none;"></div>                    </div>                                        <!-- Selected Users -->                    <div class="mb-3">                        <label class="form-label">Selected Users</label>                        <div id="selectedUsersContainer" class="border rounded p-2 min-height-50">                            <small class="text-muted">No users selected</small>                        </div>                    </div>                                        <!-- Permission Selection -->                    <div class="mb-3">                        <label for="permissionSelect" class="form-label">Permission Level</label>                        <select id="permissionSelect" class="form-select">                            <option value="Read">Read Only - Can view and download</option>                            <option value="Write">Write - Can view, download, and upload</option>                            <option value="Delete">Delete - Can view, download, upload, and delete</option>                            <option value="FullAccess">Full Access - All permissions</option>                        </select>                    </div>                                        <!-- Expiration Date -->                    <div class="mb-3">                        <label for="expirationDate" class="form-label">Expiration Date (Optional)</label>                        <input type="datetime-local" id="expirationDate" class="form-control">                        <div class="form-text">Leave empty for permanent access</div>                    </div>                </div>            `,            width: 650,            focusConfirm: false,            showCancelButton: true,            confirmButtonText: '<i class="bi bi-share me-1"></i> Share with Users',            cancelButtonText: 'Cancel',            customClass: {                popup: 'swal-wide'            },            didOpen: () => {                setupShareModal(selectedUsers);                // Add event listener for public link button                document.getElementById('createPublicLinkBtn').addEventListener('click', async () => {                    // Close current modal and open public link modal                    Swal.close();                    await createPublicLinkModal(fileId, fileName);                });            },            preConfirm: () => {                if (selectedUsers.length === 0) {                    Swal.showValidationMessage('Please select at least one user to share with');                    return false;                }                return {                    userIds: selectedUsers.map(u => u.id),                    permission: document.getElementById('permissionSelect').value,                    expiresAt: document.getElementById('expirationDate').value || null                };            }        });        if (shareData) {            await performFileShare(fileId, shareData);        }    } catch (error) {        console.error('Share dialog error:', error);        Swal.fire({            icon: 'error',            title: 'Error',            text: 'Failed to show share dialog'        });    }}function setupShareModal(selectedUsers) {    const searchBtn = document.getElementById('searchBtn');    const searchInput = document.getElementById('userSearchInput');        const performUserSearch = async () => {        const searchTerm = searchInput.value.trim();        const resultsDiv = document.getElementById('searchResults');        if (searchTerm.length < 2) {            resultsDiv.style.display = 'none';            return;        }        try {            const response = await fetch(`/User/search?term=${encodeURIComponent(searchTerm)}`, {                method: 'GET',                headers: {                    'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value                }            });            const result = await response.json();            displayUserSearchResults(result.users || [], selectedUsers);        } catch (error) {            console.error('User search error:', error);            resultsDiv.innerHTML = '<div class="p-2 text-danger">Search failed</div>';            resultsDiv.style.display = 'block';        }    };    // Search button click    searchBtn.addEventListener('click', performUserSearch);    // Enter key in search input    searchInput.addEventListener('keypress', function(e) {        if (e.key === 'Enter') {            e.preventDefault();            performUserSearch();        }    });    // Search as user types (debounced)    let searchTimeout;    searchInput.addEventListener('input', function() {        clearTimeout(searchTimeout);        searchTimeout = setTimeout(() => {            if (this.value.length >= 2) {                performUserSearch();            } else {                document.getElementById('searchResults').style.display = 'none';            }        }, 300);    });}function displayUserSearchResults(users, selectedUsers) {    const resultsDiv = document.getElementById('searchResults');    if (users.length === 0) {        resultsDiv.innerHTML = '<div class="p-2 text-muted">No users found</div>';        resultsDiv.style.display = 'block';        return;    }    const userList = users.map(user => `        <div class="user-result p-2 border-bottom" style="cursor: pointer;"              data-user-id="${user.id}" data-username="${user.username}" data-email="${user.email || ''}">            <div class="d-flex align-items-center">                <i class="bi bi-person-circle me-2 text-primary"></i>                <div>                    <div class="fw-medium">${user.username}</div>                    ${user.email ? `<small class="text-muted">${user.email}</small>` : ''}                </div>            </div>        </div>    `).join('');    resultsDiv.innerHTML = userList;    resultsDiv.style.display = 'block';    // Add click and hover effects    resultsDiv.querySelectorAll('.user-result').forEach(item => {        item.addEventListener('mouseenter', () => item.style.backgroundColor = '#f8f9fa');        item.addEventListener('mouseleave', () => item.style.backgroundColor = '');        item.addEventListener('click', () => {            const userId = item.dataset.userId;            const username = item.dataset.username;            const email = item.dataset.email;            addUserToShare(userId, username, email, selectedUsers);        });    });}function addUserToShare(userId, username, email, selectedUsers) {    // Check if user already selected    if (selectedUsers.some(u => u.id === userId)) {        showAlert('warning', 'User already selected');        return;    }    selectedUsers.push({ id: userId, username, email });    updateSelectedUsersDisplay(selectedUsers);    // Clear search and hide results    document.getElementById('userSearchInput').value = '';    document.getElementById('searchResults').style.display = 'none';}function updateSelectedUsersDisplay(selectedUsers) {    const container = document.getElementById('selectedUsersContainer');    if (selectedUsers.length === 0) {        container.innerHTML = '<small class="text-muted">No users selected</small>';        return;    }    const userTags = selectedUsers.map((user, index) => `        <span class="badge bg-primary me-2 mb-2 p-2">            <i class="bi bi-person me-1"></i>            ${user.username}            <button type="button" class="btn-close btn-close-white ms-2"                     onclick="removeUserFromShare(${index}, this)" style="font-size: 0.7em;"></button>        </span>    `).join('');    container.innerHTML = userTags;}function removeUserFromShare(userIndex, buttonElement) {    // Find the badge element and remove it    const badge = buttonElement.closest('.badge');    if (badge) {        badge.remove();    }    // Update the container display    const container = document.getElementById('selectedUsersContainer');    const remainingBadges = container.querySelectorAll('.badge');    if (remainingBadges.length === 0) {        container.innerHTML = '<small class="text-muted">No users selected</small>';    }}async function performFileShare(fileId, shareData) {    try {        const response = await fetch('/File/share', {            method: 'POST',            headers: {                'Content-Type': 'application/json',                'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value            },            body: JSON.stringify({                fileId: fileId,                userIds: shareData.userIds,                permission: shareData.permission,                expiresAt: shareData.expiresAt            })        });        const result = await response.json();        if (result.success) {            Swal.fire({                icon: 'success',                title: 'Success!',                text: result.message || 'File shared successfully',                timer: 2000,                showConfirmButton: false            });        } else {            Swal.fire({                icon: 'error',                title: 'Share Failed',                text: result.message || 'Failed to share file'            });        }    } catch (error) {        console.error('Share error:', error);        Swal.fire({            icon: 'error',            title: 'Network Error',            text: 'Failed to share file. Please try again.'        });    }}    async function createPublicLinkModal(fileId, fileName) {        try {            const { value: linkData } = await Swal.fire({                title: 'Create Public Link',                html: `                <div class="text-start">                    <div class="alert alert-info mb-3">                        <i class="bi bi-link me-2"></i>Creating public link for: <strong>${fileName}</strong>                    </div>                                        <!-- Permission Selection -->                    <div class="mb-3">                        <label for="publicPermissionSelect" class="form-label">Permission Level</label>                        <select id="publicPermissionSelect" class="form-select">                            <option value="1">Read Only - Download access</option>                            <option value="2">Write - Download and upload access</option>                            <option value="3">Delete - Download, upload, and delete access</option>                            <option value="4">Full Access - All permissions</option>                        </select>                    </div>                                        <!-- Expiration Date -->                    <div class="mb-3">                        <label for="publicExpirationDate" class="form-label">Expiration Date (Optional)</label>                        <input type="datetime-local" id="publicExpirationDate" class="form-control">                        <div class="form-text">Leave empty for permanent access</div>                    </div>                </div>            `,                width: 500,                focusConfirm: false,                showCancelButton: true,                confirmButtonText: '<i class="bi bi-link-45deg me-1"></i> Create Link',                cancelButtonText: 'Back to Share Options',                customClass: {                    popup: 'swal-wide'                },                preConfirm: () => {                    return {                        permission: parseInt(document.getElementById('publicPermissionSelect').value),                        expiresAt: document.getElementById('publicExpirationDate').value || null                    };                }            });            if (linkData) {                await performCreatePublicLink(fileId, linkData);            } else {                // User clicked "Back to Share Options" - reopen share modal                await shareFile(fileId, fileName);            }        } catch (error) {            console.error('Create public link dialog error:', error);            Swal.fire({                icon: 'error',                title: 'Error',                text: 'Failed to show public link dialog'            });        }            }    async function performCreatePublicLink(fileId, linkData) {        try {            const response = await fetch('/File/public-link', {                method: 'POST',                headers: {                    'Content-Type': 'application/json',                    'RequestVerificationToken': document.querySelector('input[name="__RequestVerificationToken"]').value                },                body: JSON.stringify({                    fileId: fileId,                    permission: linkData.permission,                    expiresAt: linkData.expiresAt                })            });            const result = await response.json();            if (result.success) {                // Show the created link in a new modal                const publicUrl = `${window.location.origin}/public/${result.share.publicLinkToken}`;                Swal.fire({                    title: 'Public Link Created!',                    html: `                    <div class="text-start">                        <div class="alert alert-success">                            <i class="bi bi-check-circle me-2"></i>Public link created successfully!                        </div>                                                <div class="mb-3">                            <label class="form-label">Share this link:</label>                            <div class="input-group">                                <input type="text" class="form-control" value="${publicUrl}" readonly id="publicLinkUrl">                                <button class="btn btn-outline-secondary" type="button" onclick="copyToClipboard('publicLinkUrl')">                                    <i class="bi bi-clipboard"></i>                                </button>                            </div>                        </div>                                                <small class="text-muted">                            <i class="bi bi-info-circle me-1"></i>                            Permission: ${getPermissionName(linkData.permission)}                            ${linkData.expiresAt ? `<br>Expires: ${new Date(linkData.expiresAt).toLocaleString()}` : '<br>Never expires'}                        </small>                    </div>                `,                    width: 600,                    confirmButtonText: 'Done',                    customClass: {                        popup: 'swal-wide'                    }                });            } else {                Swal.fire({                    icon: 'error',                    title: 'Failed to Create Link',                    text: result.message || 'Failed to create public link'                });            }        } catch (error) {            console.error('Create public link error:', error);            Swal.fire({                icon: 'error',                title: 'Network Error',                text: 'Failed to create public link. Please try again.'            });        }    }    function copyToClipboard(elementId) {        const element = document.getElementById(elementId);        element.select();        document.execCommand('copy');        // Show feedback        const button = element.nextElementSibling;        const originalHTML = button.innerHTML;        button.innerHTML = '<i class="bi bi-check"></i>';        setTimeout(() => {            button.innerHTML = originalHTML;        }, 1000);    }    function getPermissionName(permission) {        switch(permission) {            case 1: return 'Read Only';            case 2: return 'Write';            case 3: return 'Delete';            case 4: return 'Full Access';            default: return 'Unknown';        }    }    // Full-Width Top Banner System// Improved Banner System: attaches below navbar, smooth transitions, no white flash// Show banner above navbar, push navbar down smoothlyfunction showBanner(message, type = 'success', duration = 5000) {    const existingBanner = document.querySelector('.top-banner');    if (existingBanner) existingBanner.remove();    const bannerTypes = {        success: { bg: '#065143', text: '#F5F0F6', img: '/img/icons/success.png', border: '#0DAB8E' },        error: { bg: '#DE3C4B', text: '#F5F0F6', img: '/img/icons/error.png', border: '#D12335' },        warning: { bg: '#E4626F', text:  '#F5F0F6', img: '/img/icons/warning.png', border: '#F7A1AE' },        info: { bg: '#3A97E4', text:'#F5F0F6', img: '/img/icons/info.png', border: '#5DA9E9' }    };    const config = bannerTypes[type] || bannerTypes.success;    const banner = document.createElement('div');    banner.className = 'top-banner';    banner.innerHTML = `        <div class="banner-content" style="display:flex;align-items:center;justify-content:space-between;width:100%;">            <div class="banner-left" style="display:flex;align-items:center;">             <img src="${config.img}" class="banner-icon-img me-2" alt="${type} icon" />                <span class="banner-message">${message}</span>            </div>            <button class="banner-close" style="background:none;border:none;font-size:1.2em;cursor:pointer;" aria-label="Close banner">                <i class="bi bi-x"></i>            </button>        </div>    `;    banner.style.cssText = `        width: 100%;        background: ${config.bg};        color: ${config.text};        border-bottom: 2px solid ${config.border};        font-family: 'Azeret Mono', monospace;        font-weight: 500;        font-size: 0.95rem;        box-shadow: 0 2px 10px rgba(0,0,0,0.04);        opacity: 0;        transform: translateY(-20px);        transition: opacity 0.4s cubic-bezier(.4,0,.2,1), transform 0.4s cubic-bezier(.4,0,.2,1);        z-index: 1050;        position: relative;        height: 50px;    `;    // Insert banner before navbar    const navbar = document.querySelector('.navbar, #navbar');    if (navbar && navbar.parentNode) {        navbar.parentNode.insertBefore(banner, navbar);        // Push navbar down        navbar.style.transition = 'margin-top 0.4s cubic-bezier(.4,0,.2,1)';        navbar.style.marginTop = '50px';    } else {        document.body.insertBefore(banner, document.body.firstChild);    }    setTimeout(() => {        banner.style.opacity = '1';        banner.style.transform = 'translateY(0)';    }, 10);    banner.querySelector('.banner-close').onclick = () => closeBanner(banner, navbar);    if (duration > 0) {        setTimeout(() => {            closeBanner(banner, navbar);        }, duration);    }}function closeBanner(bannerElement = null, navbar = null) {    const banner = bannerElement || document.querySelector('.top-banner');    navbar = navbar || document.querySelector('.navbar, #navbar');    if (banner) {        banner.style.opacity = '0';        banner.style.transform = 'translateY(-20px)';        setTimeout(() => {            if (banner.parentNode) banner.parentNode.removeChild(banner);            if (navbar) navbar.style.marginTop = '0';        });    }}// Preset banner functionsfunction showSuccessBanner(message, duration = 5000) {    showBanner(message, 'success', duration);}function showErrorBanner(message, duration = 6000) {    showBanner(message, 'error', duration);}function showWarningBanner(message, duration = 5000) {    showBanner(message, 'warning', duration);}function showInfoBanner(message, duration = 5000) {    showBanner(message, 'info', duration);}function showWelcomeBanner(username) {    showSuccessBanner(`Welcome back, ${username}! You're successfully logged in to KCloud.`, 4000);}