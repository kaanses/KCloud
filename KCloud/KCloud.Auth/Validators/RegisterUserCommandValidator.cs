// KCloud.Auth/Features/Authentication/Validators/RegisterUserCommandValidator.csusing FluentValidation;using KCloud.Auth.Features.Authentication.Commands;using KCloud.Auth.Interfaces;using KCloud.Auth.Models;using Microsoft.EntityFrameworkCore;namespace KCloud.Auth.Validators;public class RegisterUserCommandValidator : AbstractValidator<RegisterUserCommand>{    private readonly IUnitOfWork _unitOfWork;        public RegisterUserCommandValidator(IUnitOfWork unitOfWork)    {        _unitOfWork = unitOfWork;                RuleFor(x => x.Username)            .NotEmpty().WithMessage("Username is required")            .MinimumLength(3).WithMessage("Username must be at least 3 characters")            .MaximumLength(50).WithMessage("Username must not exceed 50 characters")            .MustAsync(BeUniqueUsername).WithMessage("Username is already taken");        RuleFor(x => x.Email)            .NotEmpty().WithMessage("Email is required")            .EmailAddress().WithMessage("Email must be a valid email address")            .MustAsync(BeUniqueEmail).WithMessage("Email is already registered");        RuleFor(x => x.Password)            .NotEmpty().WithMessage("Password is required")            .MinimumLength(6).WithMessage("Password must be at least 6 characters")            .Matches("[A-Z]").WithMessage("Password must contain at least one uppercase letter")            .Matches("[0-9]").WithMessage("Password must contain at least one number");    }        private async Task<bool> BeUniqueUsername(string username, CancellationToken cancellationToken)    {        var usernameExists = await _unitOfWork.Repository<User>()            .Query()            .AnyAsync(u => u.Username.ToLower() == username.ToLower(), cancellationToken);        return !usernameExists;    }        private async Task<bool> BeUniqueEmail(string email, CancellationToken cancellationToken)    {        var emailExists = await _unitOfWork.Repository<User>()            .Query()            .AnyAsync(u => u.Email.ToLower() == email.ToLower(), cancellationToken);        return !emailExists;    }}