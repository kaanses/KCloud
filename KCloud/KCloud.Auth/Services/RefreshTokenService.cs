using System.Security.Cryptography;using KCloud.Auth.Interfaces;using KCloud.Auth.Models.Entity;using Microsoft.EntityFrameworkCore;namespace KCloud.Auth.Services;public class RefreshTokenService : IRefreshTokenService{    private readonly IUnitOfWork _unitOfWork;    private readonly IConfiguration _configuration;    private readonly ILogger<RefreshTokenService> _logger;    private readonly int _refreshTokenExpiryDays;    public RefreshTokenService(        IUnitOfWork unitOfWork,        IConfiguration configuration,        ILogger<RefreshTokenService> logger)    {        _unitOfWork = unitOfWork;        _configuration = configuration;        _logger = logger;        _refreshTokenExpiryDays = configuration.GetValue("Jwt:RefreshTokenExpiryDays", 7);    }    public async Task<string> GenerateRefreshTokenAsync(Guid userId, CancellationToken cancellationToken = default)    {        // ✅ IMPROVED: Efficient query        var existingToken = await _unitOfWork.Repository<RefreshToken>()            .Query()            .FirstOrDefaultAsync(rt => rt.UserId == userId, cancellationToken);                if (existingToken != null)        {            _unitOfWork.Repository<RefreshToken>().Delete(existingToken);        }        var newToken = new RefreshToken        {            Token = GenerateSecureToken(),            ExpiryTime = DateTime.UtcNow.AddDays(_refreshTokenExpiryDays),            UserId = userId        };                await _unitOfWork.Repository<RefreshToken>().AddAsync(newToken, cancellationToken);        await _unitOfWork.CommitAsync(cancellationToken);        return newToken.Token;    }    // ✅ SIMPLE: Just validate, don't consume    public async Task<bool> ValidateRefreshTokenAsync(Guid userId, string token, CancellationToken cancellationToken = default)    {        var refreshToken = await _unitOfWork.Repository<RefreshToken>()            .Query()            .FirstOrDefaultAsync(rt => rt.UserId == userId && rt.Token == token, cancellationToken);        if (refreshToken == null)        {            _logger.LogWarning("No refresh token found for user {UserId}", userId);            return false;        }        if (refreshToken.ExpiryTime <= DateTime.UtcNow)        {            _logger.LogWarning("Refresh token expired for user {UserId}", userId);                        // ✅ CLEANUP: Remove expired token            _unitOfWork.Repository<RefreshToken>().Delete(refreshToken);            await _unitOfWork.CommitAsync(cancellationToken);                        return false;        }        return true;    }    public async Task<bool> RevokeRefreshTokenAsync(Guid userId, CancellationToken cancellationToken = default)    {        var refreshToken = await _unitOfWork.Repository<RefreshToken>()            .Query()            .FirstOrDefaultAsync(rt => rt.UserId == userId, cancellationToken);        if (refreshToken == null)            return false;        _unitOfWork.Repository<RefreshToken>().Delete(refreshToken);        await _unitOfWork.CommitAsync(cancellationToken);        return true;    }    private string GenerateSecureToken()    {        var randomBytes = new byte[32];        using var rng = RandomNumberGenerator.Create();        rng.GetBytes(randomBytes);        return Convert.ToBase64String(randomBytes);    }}