using System.Security.Cryptography;using KCloud.Auth.Interfaces;using KCloud.Auth.Models.Entity;using Microsoft.EntityFrameworkCore;namespace KCloud.Auth.Services;public class RefreshTokenService : IRefreshTokenService{    private readonly IUnitOfWork _unitOfWork;    private readonly IConfiguration _configuration;    private readonly ILogger<RefreshTokenService> _logger;    private readonly int _refreshTokenExpiryDays;    public RefreshTokenService(        IUnitOfWork unitOfWork,        IConfiguration configuration,        ILogger<RefreshTokenService> logger)    {        _unitOfWork = unitOfWork;        _configuration = configuration;        _logger = logger;        _refreshTokenExpiryDays = configuration.GetValue("Jwt:RefreshTokenExpiryDays", 7);    }    public async Task<string> GenerateRefreshTokenAsync(Guid userId, CancellationToken cancellationToken = default)    {        // âœ… IMPROVED: Efficient query        var existingToken = await _unitOfWork.Repository<RefreshToken>()            .Query()            .FirstOrDefaultAsync(rt => rt.UserId == userId, cancellationToken);                if (existingToken != null)        {            _unitOfWork.Repository<RefreshToken>().Delete(existingToken);        }        var newToken = new RefreshToken        {            Token = GenerateSecureToken(),            ExpiryTime = DateTime.UtcNow.AddDays(_refreshTokenExpiryDays),            UserId = userId        };                await _unitOfWork.Repository<RefreshToken>().AddAsync(newToken, cancellationToken);        await _unitOfWork.CommitAsync(cancellationToken);        return newToken.Token;    }        public async Task<User?> GetUserByRefreshTokenAsync(string token, CancellationToken cancellationToken = default)    {        try        {            var refreshToken = await _unitOfWork.Repository<RefreshToken>()                .Query()                .Include(rt => rt.User)                .FirstOrDefaultAsync(rt => rt.Token == token, cancellationToken);            if (refreshToken == null)            {                _logger.LogWarning("No refresh token found");                return null;            }            if (refreshToken.ExpiryTime <= DateTime.UtcNow)            {                _logger.LogWarning("Refresh token expired for user {UserId}", refreshToken.UserId);                            _unitOfWork.Repository<RefreshToken>().Delete(refreshToken);                await _unitOfWork.CommitAsync(cancellationToken);                            return null;            }            return refreshToken.User;        }        catch (Exception ex)        {            _logger.LogError(ex, "Error validating refresh token");            return null;        }    }        public async Task<bool> RevokeRefreshTokenAsync(Guid userId, CancellationToken cancellationToken = default)    {        var refreshToken = await _unitOfWork.Repository<RefreshToken>()            .Query()            .FirstOrDefaultAsync(rt => rt.UserId == userId, cancellationToken);        if (refreshToken == null)            return false;        _unitOfWork.Repository<RefreshToken>().Delete(refreshToken);        await _unitOfWork.CommitAsync(cancellationToken);        return true;    }    private string GenerateSecureToken()    {        var randomBytes = new byte[64];        using var rng = RandomNumberGenerator.Create();        rng.GetBytes(randomBytes);        return Convert.ToBase64String(randomBytes);    }}